 set_safety_mode_transition_hardness(1)
  set_gravity([0.0, 0.0, 9.82])
  step_count_891dc0ee_3204_4d1a_87db_b30728c4e150 = 0
  thread Step_Counter_Thread_cdc5c90a_c789_4076_a75a_c62a79979c8a():
    while (True):
      step_count_891dc0ee_3204_4d1a_87db_b30728c4e150 = step_count_891dc0ee_3204_4d1a_87db_b30728c4e150 + 1
      sync()
    end
  end
  run Step_Counter_Thread_cdc5c90a_c789_4076_a75a_c62a79979c8a()
  set_tcp(p[0.0,0.0,0.0,0.0,0.0,0.0])
  set_payload(0.0)
  set_tool_communication(True, 1000000, 2, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  # begin: URCap Installation Node
  #   Source: FT-OnRobot, 4.1.4, OnRobot A/S
  #   Type: OnRobot FT Setup
  of_robot_type = 5
  of_sensor_IP = "*SensorIp*"
  OF_DEBUG_STATE = False
  of_mounting_qc_use = False
  of_install_tcp = False
  of_mounting_bracket_angle = 180
  of_mounting_gripper_angle = 0
  of_gripper_follow_fingertip = True
  of_gripper_part_tcp_offset_xyz = [0.0,0.0,0.0]
  of_gripper_part_tcp_offset_rpy = [0.0,0.0,0.0]
  of_gripper_install_cog2tcp = True
  of_gripper_part_cog_offset = [0.0,0.0,0.0]
  of_gripper_part_cog_mass = 0.0
  of_proxi_offsets = [16.7125, 18.53]
    #======    OnRobot Globals    ======#
  
    OF_DEBUG_GLOBAL=False
    OF_DEBUG_CMD=False
    OF_DEBUG_TX=False
    OF_DEBUG_RX=False
    OF_DEBUG_VAR=False
    global of_return=0
    Fx=0
    Fy=0
    Fz=0
    Tx=0
    Ty=0
    Tz=0
    F3D=0
    T3D=0
    bFT=[0,0,0,0,0,0]
    tFT=[0,0,0,0,0,0]
    global rg_FT_left=[0,0,0,0,0,0]
    global rg_FT_right=[0,0,0,0,0,0]
    global rg_F3D_left=0
    global rg_F3D_right=0
    global rg_T3D_left=0
    global rg_T3D_right=0
    global rg_Prox_left=0
    global rg_Prox_right=0
    global rg_Width=0
    rg_Grip_detected=False
    rg_Grip_lost=False
    rg_Gripped=False
    rg_Slip_alert=False
    rg_Part_weight=0
    global rg_Part_width=0
    rg_Gyro=[0,0,0]
    of_speedbase=[0,0,0,0,0,0]
    of_sensor_id=0
    of_sensor_status=0
    of_engine_state=0
    of_compute_engine_ping=0
    of_compute_engine_ping_max=0
    ZEROPOSE=p[0,0,0,0,0,0]
    ZEROFRAME=p[0,0,0,0,0,0]
    FALSE6D=[False,False,False,False,False,False]
    FALSE8D=[False,False,False,False,False,False,False,False]
    of_robot_TCP_offset=ZEROFRAME
    of_parent_of_move_frameID=0
    of_parent_of_move_frame=ZEROFRAME
    of_hex_qc_offset=p[0,0,0,0,0,0]
    rg_Status_left=0
    rg_Status_right=0
    rg_Status_backpack=0
    rg_ghex=True
    of_gripper_qc_offset=p[0,0,0,0,0,0]
    of_gripper_bracket_offset=p[0,0,0,0,0,0]
    of_gripper_mount_offset=p[0,0,0,0,0,0]
    of_gripper_mounted_mass=0
    of_gripper_mounted_cog=p[0,0,0,0,0,0]
    def of_wait_ms(time_ms):
    local sync_time=norm(time_ms/2.0)
    while(sync_time>0):
    sync_time=sync_time-1
    sync()
    end
    end
  
  
    #======    End of OnRobot Globals    ======#
  
    #======    OnRobot Interface Messages    ======#
  
    of_ce_comm_error_textmsg_title="OnRobot - Communication error: "
    of_ce_comm_controlsocket_open_error="Socket 'controlSocket' opening was unsuccessful."
    of_ce_comm_commandflow_open_error="Socket 'commandFlow opening was unsuccessful."
    of_ce_comm_vectorstream_open_error="Socket 'vectorStream' opening was unsuccessful."
    of_ce_comm_vectorstream_packet_error="Socket 'vectorStream' packet error."
    of_ce_comm_error_title="OnRobot - Communication error"
    of_ce_comm_socket_open_error="Establishing connection with the Compute Box was timed out.<br>Ensure that the Compute Box is operational, and check the status in the OnRobot Setup page in the Installation Tab."
    of_ce_comm_socket_packet_error="Communication packet error.<br>Ensure that the Compute Box is operational, and check the status in the OnRobot Setup page in the Installation Tab."
    of_ce_comm_safeguard_lost_error="Connection was lost with the Compute Box, program stopped. Restart the Compute Box, and check the status in the OnRobot Setup page in the Installation Tab."
    of_ce_comm_cmd_send_error="Command sending to the Compute Box failed. Resending. Command: "
    of_ce_comm_cmd_send_again="Try to send command again.."
    of_ce_comm_int_send_error="Integer sending to the Compute Box failed. Resending. Integer: "
    of_ce_comm_int_send_again="Try to send int again.."
    of_ce_comm_float_send_error="Float sending to the Compute Box failed. Resending. Float: "
    of_ce_comm_float_send_again="Try to send float as int again.."
    of_ce_comm_dummy_send_error="Dummy sending to the Compute Box failed. Resending. [Counter, out of]: "
    of_ce_comm_dummy_send_again="Try to send dummy again.."
    of_cmd_error_title="OnRobot - Command error"
    of_cmd_rx_invalid_id="Invalid Command ID"
    of_cmd_rx_wrong_state="Wrong command state."
    of_cmd_rx_error_length="Unknown command-length received: "
    of_float_to_int_overflow="Float to int overflow! "
    of_float_to_int_underflow="Float to int underflow! "
  
  
    #======    End of OnRobot Interface Messages    ======#
  
    #======    OnRobot Interface    ======#
  
    of_compute_engine_ping=0
    of_compute_engine_ping_max=0
    of_compute_engine_IP=""
    OF_APP_ENGINE_PORT=0
    OF_COMMAND_PORT=0
    OF_VECTOR_STREAM_PORT=0
    of_portopened_controlSocket=False
    of_portopened_vectorStream=False
    of_portopened_commandFlow=False
    of_v2r_received=0
    of_cmd_received=0
    of_sg_count=0
    of_dataAVFT=[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    of_data=[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    of_cmd_state=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    of_cmd_return=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    of_cmd_rx=[0,0,0]
    of_ack_received=False
    OF_COMPUTE_ENGINE_PING_LIMIT=19
    OF_COMPUTE_ENGINE_PING_DESC=0.05
    OF_APP_ENGINE_PORT=51234
    OF_COMMAND_PORT=OF_APP_ENGINE_PORT
    OF_VECTOR_STREAM_PORT=OF_APP_ENGINE_PORT+1
    OF_SCALE_FLOAT=1000000
    OF_CMD_STATE_IDLE=0
    OF_CMD_STATE_STARTED=1
    OF_CMD_STATE_RETURNING=2
    OF_CMD_STATE_INTERRUPTED=3
    OF_CMD_ACK=0
    OF_CMD_STOP=1
    OF_CMD_START=2
    OF_CMD_BIAS=3
    OF_CMD_TCP=4
    OF_CMD_SENSOR_CONFIG=5
    OF_CMD_PAYLOAD=6
    OF_CMD_LIMIT=7
    OF_CMD_FT_CONTROL=8
    OF_CMD_HAND_GUIDE=9
    OF_CMD_MOVE=10
    OF_CMD_WAYPOINT=11
    OF_CMD_PATH=12
    OF_CMD_DIO=13
    OF_CMD_AIO=14
    OF_CMD_INSERT_PIN=15
    OF_CMD_GRIPPER_SET_WIDTH=16
    OF_CMD_GRIPPER_SET_LEDS=17
    OF_CMD_GRIPPER_STOP=18
    OF_CMD_GRIPPER_CENTERING=19
    OF_CMD_GRIPPER_PROXI_OFFSETS=20
    OF_CMD_GRIPPER_PROXI_AVG_WINDOW=21
    OF_CMD_GRIPPER_WIDTH_FILTERING=22
    OF_CMD_GRIPPER_MOUNT=23
    OF_CMD_TX_PARAM_LENGTH=20
    OF_DUMMY_VALUE=-1
    def of_float_to_int(value):
    if value>(2147483647/OF_SCALE_FLOAT):
    textmsg(of_float_to_int_overflow,value)
    value=2147483647/OF_SCALE_FLOAT
    elif value<(-2147483648/OF_SCALE_FLOAT):
    textmsg(of_float_to_int_underflow,value)
    value=-2147483648/OF_SCALE_FLOAT
    end
    return value*OF_SCALE_FLOAT
    end
    def of_int_to_float(value):
    return value/OF_SCALE_FLOAT
    end
    def of_portclose_controlSocket():
    socket_close("controlSocket")
    of_portopened_controlSocket=False
    end
    def of_portopen_controlSocket():
    of_portclose_controlSocket()
    of_portopened_controlSocket=socket_open("127.0.0.1",44005,"controlSocket")
    if not of_portopened_controlSocket:
    textmsg(of_ce_comm_error_textmsg_title,of_ce_comm_controlsocket_open_error)
    popup(of_ce_comm_socket_open_error,title=of_ce_comm_error_title,error=True,blocking=False)
    halt
    end
    end
    def of_portclose_vectorStream():
    socket_close("vectorStream")
    of_portopened_vectorStream=False
    end
    def of_portopen_vectorStream():
    of_portclose_vectorStream()
    of_portopened_vectorStream=socket_open(of_compute_engine_IP,OF_VECTOR_STREAM_PORT,"vectorStream")
    if not of_portopened_vectorStream:
    of_portopened_vectorStream=socket_open(of_compute_engine_IP,OF_VECTOR_STREAM_PORT,"vectorStream")
    end
    if not of_portopened_vectorStream:
    textmsg(of_ce_comm_error_title,of_ce_comm_vectorstream_open_error)
    popup(of_ce_comm_socket_open_error,title=of_ce_comm_error_title,error=True,blocking=False)
    halt
    end
    end
    thread of_vectorStream_thread():
    if OF_DEBUG_STATE:
    textmsg("Starting vectorStream thread")
    end
    while of_portopened_vectorStream:
    of_data=socket_read_ascii_float(30,"vectorStream",0)
    if of_data[0]==30:
    enter_critical
    of_dataAVFT=of_data
    of_v2r_received=of_v2r_received+1
    exit_critical
    else:
    textmsg("Received of_data: ",of_data)
    textmsg(of_ce_comm_error_textmsg_title,of_ce_comm_vectorstream_packet_error)
    popup(of_ce_comm_socket_packet_error,title=of_ce_comm_error_title,error=True,blocking=False)
    halt
    end
    end
    if OF_DEBUG_STATE:
    textmsg("Stopping vectorStream thread")
    end
    end
    thread of_safeguard_thread():
    if OF_DEBUG_STATE:
    textmsg("SafeGuard thread starting..")
    end
    while(of_sensor_id==OF_SENSOR_ID_UNDEFINED):
    sync()
    end
    of_sg_count=of_v2r_received
    while of_portopened_vectorStream:
    sync()
  
    sync()
    sync()
    sync()
  
    of_sg_count=of_sg_count+1
    of_compute_engine_ping=of_sg_count-of_v2r_received
    if of_compute_engine_ping>OF_COMPUTE_ENGINE_PING_LIMIT:
    textmsg(of_ce_comm_safeguard_lost_error)
    popup(of_ce_comm_safeguard_lost_error,title=of_ce_comm_error_title,error=True,blocking=False)
    halt
    end
    if of_compute_engine_ping>of_compute_engine_ping_max:
    of_compute_engine_ping_max=of_compute_engine_ping
    end
    of_sg_count=of_sg_count-OF_COMPUTE_ENGINE_PING_DESC*of_compute_engine_ping
    end
    if OF_DEBUG_STATE:
    textmsg("SafeGuard thread stopped")
    end
    end
    def of_portclose_commandFlow():
    socket_close("commandFlow")
    of_portopened_commandFlow=False
    end
    def of_portopen_commandFlow():
    of_portclose_commandFlow()
    of_portopened_commandFlow=socket_open(of_compute_engine_IP,OF_COMMAND_PORT,"commandFlow")
    if not of_portopened_commandFlow:
    of_portopened_commandFlow=socket_open(of_compute_engine_IP,OF_COMMAND_PORT,"commandFlow")
    end
    if not of_portopened_commandFlow:
    textmsg(of_ce_comm_error_textmsg_title,of_ce_comm_commandflow_open_error)
    popup(of_ce_comm_socket_open_error,title=of_ce_comm_error_title,error=True,blocking=False)
    halt
    end
    end
    thread of_commandFlow_thread():
    if OF_DEBUG_STATE:
    textmsg("Starting commandFlow thread..")
    end
    while of_portopened_commandFlow:
    of_cmd_rx=socket_read_binary_integer(2,"commandFlow",0)
    if of_cmd_rx[0]!=0:
    parse_command()
    end
    sync()
    of_cmd_received=of_cmd_received+1
    end
    if OF_DEBUG_STATE:
    textmsg("Stopping commandFlow thread")
    end
    end
    def of_send_command(command):
    sync()
    if OF_DEBUG_CMD or OF_DEBUG_TX:
    textmsg("Sending command: ",command)
    end
    succ=socket_send_int(command,"commandFlow")
    if not succ:
    if OF_DEBUG_STATE and OF_DEBUG_TX:
    textmsg(of_ce_comm_cmd_send_error,command)
    popup(of_ce_comm_cmd_send_again,title=of_ce_comm_error_title,warning=True,blocking=False)
    end
    sync()
    of_send_command(command)
    end
    end
    def of_send_int(intvalue):
    if OF_DEBUG_TX:
    textmsg("Sending integer: ",intvalue)
    end
    local succ=socket_send_int(intvalue,"commandFlow")
    if not succ:
    if OF_DEBUG_STATE and OF_DEBUG_TX:
    textmsg(of_ce_comm_int_send_error,intvalue)
    popup(of_ce_comm_int_send_again,title=of_ce_comm_error_title,warning=True,blocking=False)
    end
    sync()
    of_send_int(intvalue)
    end
    end
    def of_send_float_as_int(floatvalue):
    local value=of_float_to_int(floatvalue)
    if OF_DEBUG_TX:
    textmsg("Sending [float, as int]: ",[floatvalue,value])
    end
    local succ=socket_send_int(value,"commandFlow")
    if not succ:
    if OF_DEBUG_STATE and OF_DEBUG_TX:
    textmsg(of_ce_comm_float_send_error,floatvalue)
    popup(of_ce_comm_float_send_again,title=of_ce_comm_error_title,warning=True,blocking=False)
    end
    sync()
    of_send_float_as_int(floatvalue)
    end
    end
    def of_send_dummies(count):
    if OF_DEBUG_TX:
    textmsg("Sending dummies: ",count)
    end
    local counter=0
    while counter<count:
    local succ=socket_send_int(OF_DUMMY_VALUE,"commandFlow")
    if not succ:
    if OF_DEBUG_STATE and OF_DEBUG_TX:
    textmsg(of_ce_comm_dummy_send_error,[(counter+1),count])
    popup(of_ce_comm_dummy_send_again,title=of_ce_comm_error_title,warning=True,blocking=False)
    end
    counter=counter-1
    sync()
    end
    counter=counter+1
    end
    end
    def of_send_full(command,arg01=OF_DUMMY_VALUE,arg02=OF_DUMMY_VALUE,arg03=OF_DUMMY_VALUE,arg04=OF_DUMMY_VALUE,arg05=OF_DUMMY_VALUE,arg06=OF_DUMMY_VALUE,arg07=OF_DUMMY_VALUE,arg08=OF_DUMMY_VALUE,arg09=OF_DUMMY_VALUE,arg10=OF_DUMMY_VALUE,arg11=OF_DUMMY_VALUE,arg12=OF_DUMMY_VALUE,arg13=OF_DUMMY_VALUE,arg14=OF_DUMMY_VALUE,arg15=OF_DUMMY_VALUE,arg16=OF_DUMMY_VALUE,arg17=OF_DUMMY_VALUE,arg18=OF_DUMMY_VALUE,arg19=OF_DUMMY_VALUE,arg20=OF_DUMMY_VALUE):
    if OF_DEBUG_TX:
    textmsg("Sending full command: ",command)
    end
    of_send_command(command)
    of_send_int(arg01)
    of_send_int(arg02)
    of_send_int(arg03)
    of_send_int(arg04)
    of_send_int(arg05)
    of_send_int(arg06)
    of_send_int(arg07)
    of_send_int(arg08)
    of_send_int(arg09)
    of_send_int(arg10)
    of_send_int(arg11)
    of_send_int(arg12)
    of_send_int(arg13)
    of_send_int(arg14)
    of_send_int(arg15)
    of_send_int(arg16)
    of_send_int(arg17)
    of_send_int(arg18)
    of_send_int(arg19)
    of_send_int(arg20)
    of_wait_for_ACK()
    if OF_DEBUG_TX:
    textmsg("Full command sent.")
    end
    end
    def of_wait_for_ACK(timeout=0):
    local timeout_sync_max=timeout*125
    local timeout_sync=0
    local timedOut=False
    if timeout>=0:
    useTimeout=True
    else:
    useTimeout=False
    end
    syncCounter=0
    enter_critical
    local ackReceived=of_ack_received
    exit_critical
    while((not ackReceived)and(not timedOut)):
    sync()
    if useTimeout:
    timeout_sync=timeout_sync+1
    if timeout_sync>timeout_sync_max:
    timedOut=True
    end
    end
    enter_critical
    ackReceived=of_ack_received
    exit_critical
    end
    enter_critical
    of_ack_received=False
    exit_critical
    end
    def of_wait_for_return(of_cmd_id,blocking):
    if not(of_cmd_state[of_cmd_id]==OF_CMD_STATE_IDLE):
    textmsg("Command state: [cmd_id, state]",[of_cmd_id,of_cmd_state[of_cmd_id]])
    popup(of_cmd_rx_wrong_state,title=of_cmd_error_title,error=True,blocking=False)
    halt
    else:
    enter_critical
    of_cmd_return[of_cmd_id]=-1
    of_cmd_state[of_cmd_id]=OF_CMD_STATE_STARTED
    exit_critical
    end
    if blocking:
    if OF_DEBUG_RX:
    textmsg("Waiting for return of CMD: ",of_cmd_id)
    end
    while of_cmd_state[of_cmd_id]==OF_CMD_STATE_STARTED:
    sync()
    end
    end
    enter_critical
    local retVal=of_cmd_return[of_cmd_id]
    of_cmd_state[of_cmd_id]=OF_CMD_STATE_IDLE
    of_cmd_return[of_cmd_id]=0
    exit_critical
    if OF_DEBUG_RX:
    textmsg("Return value received: [CMD, return]",[of_cmd_id,retVal])
    end
    return retVal
    end
    def of_wait_for_return_stop(of_cmd_id):
    enter_critical
    of_cmd_state[of_cmd_id]=OF_CMD_STATE_IDLE
    exit_critical
    end
    def parse_command():
    if of_cmd_rx[0]==0:
    if OF_DEBUG_RX:
    textmsg("Nothing received..")
    end
    elif of_cmd_rx[0]==1:
    if OF_DEBUG_RX:
    textmsg("Half command received: ",of_cmd_rx[1])
    end
    elif of_cmd_rx[0]==2:
    if of_cmd_rx[1]==OF_CMD_ACK:
    enter_critical
    of_ack_received=True
    exit_critical
    if OF_DEBUG_RX:
    textmsg("Acknowledge received")
    end
    elif of_cmd_rx[1]<20:
    enter_critical
    local cmd_id=of_cmd_rx[1]
    if(of_cmd_state[cmd_id]==OF_CMD_STATE_IDLE):
    of_cmd_return[cmd_id]=of_cmd_rx[2]
    elif(of_cmd_state[cmd_id]==OF_CMD_STATE_STARTED):
    of_cmd_return[cmd_id]=of_cmd_rx[2]
    of_cmd_state[cmd_id]=OF_CMD_STATE_RETURNING
    else:
    popup(of_cmd_rx_wrong_state,title=of_cmd_error_title,error=True,blocking=False)
    halt
    end
    exit_critical
    else:
    popup(of_cmd_rx_invalid_id,title=of_cmd_error_title,error=True,blocking=False)
    halt
    end
    else:
    textmsg("Unknown command-length received: ",of_cmd_rx)
    end
    end
  
  
    #======    End of OnRobot Interface    ======#
  
    #======    OnRobot Engine Messages    ======#
  
    of_sensor_error_title="OnRobot - Sensor error"
    of_sensor_error_type="No or unknown sensor connected.<br>Refer to the Compute Box Description on the OnRobot USB drive."
    of_sensor_error_mixed="The sensor type is not matching with the URCap mode.<br>Please make sure at the Installation tab that proper Compute Box and Sensor/Gripper settings are set, then restart the robot if needed."
    of_sensor_warning_title="OnRobot - Sensor warning: "
    of_sensor_else_error="Unknown error code(s).<br>Connect to the Compute Box Web Access, and analize the STATUS word. Refer to the Compute Box Description on the OnRobot USB drive."
  
    of_sensor_status_msg_backpack="Gripper Backpack status: "
    of_sensor_bit0_error_backpack="No sensor connected.<br>Turn off the Compute Box, connect the RG2-FT to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_bit1_error_backpack="Gripper Backpack is not responding.<br>Turn off the Compute Box, connect the RG2-FT to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_bit2_error_backpack="Gripper Backpack failure.<br>Gather information about the situation in which this error occurred, and contact your distributor."
    of_sensor_bit3_error_backpack="Gripper firmware mismatch.<br>Firmware update is available for the RG2-FT. Required updates need to be installed. Refer to the Compute Box Description on the OnRobot USB drive."
    of_sensor_bit4_error_backpack="Communication error between the Gripper Backpack and the Compute Box.<br>Turn off the Compute Box, connect the RG2-FT to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_status_msg_left="Left Sensor status: "
    of_sensor_bit0_error_left="No sensor connected.<br>Turn off the Compute Box, connect the RG2-FT to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_bit1_error_left="Left Sensor is not responding.<br>Turn off the Compute Box, connect the RG2-FT to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_bit2_error_left="Left Sensor failure.<br>Gather information about the situation in which this error occurred, and contact your distributor."
    of_sensor_bit3_error_left="Left Sensor power error.<br>Gather information about the situation in which this error occurred, and contact your distributor, or OnRobot."
    of_sensor_bit4_error_left="Communication error between the Left Sensor and the Compute Box.<br>Turn off the Compute Box, connect the RG2-FT to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_bit5_error_left="Left Sensor force overload error.<br>Eliminate the circumstances that cause the sensor to be overloaded, that is, offload the sensor."
    of_sensor_bit6_error_left="Left Sensor torque overload error.<br>Eliminate the circumstances that cause the sensor to be overloaded, that is, offload the sensor."
    of_sensor_bit7_warning_left="Left Sensor overload warning reached. Lower the force/torque to avoid damage."
    of_sensor_bit8_error_left="Left Sensor overload limit activated.<br>Lower the force/torque to avoid damage.<br>Program stopped."
    of_sensor_status_msg_right="Right Sensor status: "
    of_sensor_bit0_error_right="No sensor connected.<br>Turn off the Compute Box, connect the RG2-FT to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_bit1_error_right="Right Sensor is not responding.<br>Turn off the Compute Box, connect the RG2-FT to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_bit2_error_right="Right Sensor failure.<br>Gather information about the situation in which this error occurred, and contact your distributor."
    of_sensor_bit3_error_right="Right Sensor power error.<br>Gather information about the situation in which this error occurred, and contact your distributor, or OnRobot."
    of_sensor_bit4_error_right="Communication error between the Right Sensor and the Compute Box.<br>Turn off the Compute Box, connect the RG2-FT to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_bit5_error_right="Right Sensor force overload error.<br>Eliminate the circumstances that cause the sensor to be overloaded, that is, offload the sensor."
    of_sensor_bit6_error_right="Right Sensor torque overload error.<br>Eliminate the circumstances that cause the sensor to be overloaded, that is, offload the sensor."
    of_sensor_bit7_warning_right="Right Sensor overload warning reached. Lower the force/torque to avoid damage."
    of_sensor_bit8_error_right="Right Sensor overload limit activated.<br>Lower the force/torque to avoid damage.<br>Program stopped."
  
    of_engine_start_ip="Connecting to OnRobot Compute Box: "
  
  
    #======    End of OnRobot Engine Messages    ======#
  
    #======    OnRobot Engine    ======#
  
    sFT=[0.0,0.0,0.0,0.0,0.0,0.0]
    of_appvect=[0.0,0.0,0.0,0.0,0.0,0.0,0.0]
    of_sensor_status=0
    of_engine_state=0
    rg_lastZ_left=0
    rg_lastZ_right=0
    rg_Grip_edge=2
    OF_SENSOR_ID_UNDEFINED=0
    OF_SENSOR_ID_UNKNOWN=1
    OF_SENSOR_ID_HEX_V1=11
    OF_SENSOR_ID_HEX_V2=12
    OF_SENSOR_ID_GHEX_V0=20
    def of_error(status_flag,message,title,stop_var=False):
    if(status_flag):
    popup(message,title=title,error=True,blocking=False)
    stop_var=True
    end
    return stop_var
    end
    def of_warning(status_flag,message,title):
    if(status_flag):
    textmsg(title,message)
    end
    end
    thread of_vectorProcess_thread():
    if OF_DEBUG_STATE:
    textmsg("Starting vectorProcess thread")
    end
    while of_portopened_vectorStream:
    sync()
    of_engine_state=floor(of_dataAVFT[1]+0.5)
    of_sensor_id=floor(of_dataAVFT[2]+0.5)
    if(of_sensor_id==OF_SENSOR_ID_HEX_V1 or of_sensor_id==OF_SENSOR_ID_HEX_V2):
    rg_ghex=False
    enter_critical
    of_appvect[0]=of_dataAVFT[3]
    of_appvect[1]=of_dataAVFT[4]
    of_appvect[2]=of_dataAVFT[5]
    of_appvect[3]=of_dataAVFT[6]
    of_appvect[4]=of_dataAVFT[7]
    of_appvect[5]=of_dataAVFT[8]
    sFT[0]=of_dataAVFT[9]
    sFT[1]=of_dataAVFT[10]
    sFT[2]=of_dataAVFT[11]
    sFT[3]=of_dataAVFT[12]
    sFT[4]=of_dataAVFT[13]
    sFT[5]=of_dataAVFT[14]
    of_sensor_status=floor(of_dataAVFT[15]+0.5)
    exit_critical
    elif(of_sensor_id==OF_SENSOR_ID_GHEX_V0):
    rg_ghex=True
    enter_critical
    of_appvect[0]=of_dataAVFT[3]
    of_appvect[1]=of_dataAVFT[4]
    of_appvect[2]=of_dataAVFT[5]
    of_appvect[3]=of_dataAVFT[6]
    of_appvect[4]=of_dataAVFT[7]
    of_appvect[5]=of_dataAVFT[8]
    rg_FT_left[0]=of_dataAVFT[9]
    rg_FT_left[1]=of_dataAVFT[10]
    rg_FT_left[2]=of_dataAVFT[11]
    rg_FT_left[3]=of_dataAVFT[12]
    rg_FT_left[4]=of_dataAVFT[13]
    rg_FT_left[5]=of_dataAVFT[14]
    rg_Status_left=floor(of_dataAVFT[15]+0.5)
    rg_Status_backpack=floor(of_dataAVFT[16]+0.5)
    rg_FT_right[0]=of_dataAVFT[17]
    rg_FT_right[1]=of_dataAVFT[18]
    rg_FT_right[2]=of_dataAVFT[19]
    rg_FT_right[3]=of_dataAVFT[20]
    rg_FT_right[4]=of_dataAVFT[21]
    rg_FT_right[5]=of_dataAVFT[22]
    rg_Status_right=floor(of_dataAVFT[23]+0.5)
    rg_Gyro[0]=of_dataAVFT[24]
    rg_Gyro[1]=of_dataAVFT[25]
    rg_Gyro[2]=of_dataAVFT[26]
    rg_Prox_left=of_dataAVFT[27]
    rg_Prox_right=of_dataAVFT[28]
    rg_Width=of_dataAVFT[29]
    exit_critical
    of_sensor_status=rg_Status_backpack+256*rg_Status_left+65536*rg_Status_right
    elif(of_sensor_id==OF_SENSOR_ID_UNDEFINED):
    if OF_DEBUG_STATE:
    textmsg("Establishing connection with the sensor.. Undefined sensor: ",of_sensor_id)
    textmsg("VectorStream: ",of_dataAVFT)
    end
    else:
    textmsg("Sensor type ID: ",of_sensor_id)
    popup(of_sensor_error_type,title=of_sensor_error_title,error=True,blocking=False)
    halt
    end
    local sensor_stop=False
    sensor_stop=of_error(((True)xor(rg_ghex)),of_sensor_error_mixed,of_sensor_error_title,sensor_stop)
  
    if(rg_Status_backpack!=0):
    local sensor_status_bits=integer_to_binary_list(rg_Status_backpack)
    sensor_stop=of_error(sensor_status_bits[0],of_sensor_bit0_error_backpack,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[1],of_sensor_bit1_error_backpack,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[2],of_sensor_bit2_error_backpack,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[3],of_sensor_bit3_error_backpack,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[4],of_sensor_bit4_error_backpack,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error((rg_Status_backpack>31),of_sensor_else_error,of_sensor_error_title,sensor_stop)
    textmsg(of_sensor_status_msg_backpack,rg_Status_backpack)
    end
    if(rg_Status_left!=0):
    local sensor_status_bits=integer_to_binary_list(rg_Status_left)
    sensor_stop=of_error(sensor_status_bits[0],of_sensor_bit0_error_left,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[1],of_sensor_bit1_error_left,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[2],of_sensor_bit2_error_left,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[3],of_sensor_bit3_error_left,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[4],of_sensor_bit4_error_left,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[5],of_sensor_bit5_error_left,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[6],of_sensor_bit6_error_left,of_sensor_error_title,sensor_stop)
    of_warning(sensor_status_bits[7],of_sensor_bit7_warning_left,of_sensor_warning_title)
    sensor_stop=of_error(sensor_status_bits[8],of_sensor_bit8_error_left,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error((rg_Status_left>511),of_sensor_else_error,of_sensor_error_title,sensor_stop)
    textmsg(of_sensor_status_msg_left,rg_Status_left)
    end
    if(rg_Status_right!=0):
    local sensor_status_bits=integer_to_binary_list(rg_Status_right)
    sensor_stop=of_error(sensor_status_bits[0],of_sensor_bit0_error_right,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[1],of_sensor_bit1_error_right,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[2],of_sensor_bit2_error_right,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[3],of_sensor_bit3_error_right,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[4],of_sensor_bit4_error_right,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[5],of_sensor_bit5_error_right,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error(sensor_status_bits[6],of_sensor_bit6_error_right,of_sensor_error_title,sensor_stop)
    of_warning(sensor_status_bits[7],of_sensor_bit7_warning_right,of_sensor_warning_title)
    sensor_stop=of_error(sensor_status_bits[8],of_sensor_bit8_error_right,of_sensor_error_title,sensor_stop)
    sensor_stop=of_error((rg_Status_right>511),of_sensor_else_error,of_sensor_error_title,sensor_stop)
    textmsg(of_sensor_status_msg_right,rg_Status_right)
    end
  
    if sensor_stop:
    halt
    end
    local tcp_transform=of_robot_TCP_offset
    tcp_transform[0]=0
    tcp_transform[1]=0
    tcp_transform[2]=0
    tcp_transform=pose_inv(tcp_transform)
    local tcpF=pose_trans(tcp_transform,p[sFT[0],sFT[1],sFT[2],0,0,0])
    local tcpT=pose_trans(tcp_transform,p[sFT[3],sFT[4],sFT[5],0,0,0])
    Fx=tcpF[0]
    Fy=tcpF[1]
    Fz=tcpF[2]
    Tx=tcpT[0]
    Ty=tcpT[1]
    Tz=tcpT[2]
    F3D=sqrt(Fx*Fx+Fy*Fy+Fz*Fz)
    T3D=sqrt(Tx*Tx+Ty*Ty+Tz*Tz)
    if(of_sensor_id==OF_SENSOR_ID_GHEX_V0):
    enter_critical
    rg_F3D_left=sqrt(rg_FT_left[0]*rg_FT_left[0]+rg_FT_left[1]*rg_FT_left[1]+rg_FT_left[2]*rg_FT_left[2])
    rg_F3D_right=sqrt(rg_FT_right[0]*rg_FT_right[0]+rg_FT_right[1]*rg_FT_right[1]+rg_FT_right[2]*rg_FT_right[2])
    rg_T3D_left=sqrt(rg_FT_left[3]*rg_FT_left[3]+rg_FT_left[4]*rg_FT_left[4]+rg_FT_left[5]*rg_FT_left[5])
    rg_T3D_right=sqrt(rg_FT_right[3]*rg_FT_right[3]+rg_FT_right[4]*rg_FT_right[4]+rg_FT_right[5]*rg_FT_right[5])
    if((rg_FT_left[2]-rg_lastZ_left>rg_Grip_edge)and(rg_FT_right[2]-rg_lastZ_right>rg_Grip_edge)):
    rg_Grip_detected=True
    rg_Gripped=True
    end
    if((rg_FT_left[2]-rg_lastZ_left<-rg_Grip_edge)and(rg_FT_right[2]-rg_lastZ_right<-rg_Grip_edge)):
    rg_Grip_lost=True
    rg_Gripped=False
    end
    rg_Slip_alert=((sqrt(pow(rg_FT_left[0],2)+pow(rg_FT_left[1],2))>rg_FT_left[2]*0.5)or(sqrt(pow(rg_FT_right[0],2)+pow(rg_FT_right[1],2))>rg_FT_right[2]*0.5))
    rg_Part_width=rg_Width-(rg_Prox_left+rg_Prox_right)
    if rg_Part_width<0:
    if rg_Part_width<-0.5*rg_Width:
    rg_Part_width=-1
    else:
    rg_Part_width=0
    end
    end
    if rg_Part_width>=0:
    rg_Part_weight=sqrt(pow((rg_FT_left[0]+rg_FT_right[0]),2)+pow((rg_FT_left[1]+rg_FT_right[1]),2)+pow((rg_FT_left[2]+rg_FT_right[2]),2))
    else:
    rg_Part_weight=-1
    end
    rg_lastZ_left=rg_FT_left[2]
    rg_lastZ_right=rg_FT_right[2]
    exit_critical
    end
    local act_transform=get_actual_tool_flange_pose()
    act_transform[0]=0
    act_transform[1]=0
    act_transform[2]=0
    local bF=pose_trans(act_transform,p[sFT[0],sFT[1],sFT[2],0,0,0])
    local bT=pose_trans(act_transform,p[sFT[3],sFT[4],sFT[5],0,0,0])
    bFT=[bF[0],bF[1],bF[2],bT[0],bT[1],bT[2]]
    tFT=[Fx,Fy,Fz,Tx,Ty,Tz]
    of_appvect[6]=of_v2r_received
    end
    if OF_DEBUG_STATE:
    textmsg("Stopping vectorProcess thread")
    end
    end
    def get_of_appvect():
    return[of_appvect[0],of_appvect[1],of_appvect[2],of_appvect[3],of_appvect[4],of_appvect[5]]
    end
    def get_of_appvect_pose():
    return p[of_appvect[0],of_appvect[1],of_appvect[2],of_appvect[3],of_appvect[4],of_appvect[5]]
    end
  
  
    #======    End of OnRobot Engine    ======#
  
    #======    OnRobot Speedl    ======#
  
    of_speedl_thread_handler=0
    of_speedl_is_enabled=False
    of_speedl_is_running=False
    of_speedbase=[0,0,0,0,0,0]
    of_speedl_acc=0
    of_speedl_hg_caranteen_reached=False
    of_speedl_hg_caranteen_safemode=False
    of_speedl_for_limit=False
    of_speedl_for_ft_control=False
    of_speedl_for_move=False
    of_speedl_for_hand_guide=False
    of_speedl_for_insert_pin=False
    of_speedl_for_gripper_set_width=False
    of_speedl_for_gripper_centering=False
    of_speedl_acc=10000.0
    of_speedl_acc_to_zero=3.0
    thread of_speedl_thread():
    if OF_DEBUG_STATE:
    textmsg("Speedl stream started..")
    end
    enter_critical
    of_speedl_is_running=True
    of_speedl_is_enabled=True
    exit_critical
    of_speedbase=[0,0,0,0,0,0]
    while of_speedl_is_running:
    of_speedbase=get_of_appvect()
    if of_speedl_for_hand_guide:
    if of_speedl_hg_caranteen_reached:
    if of_speedl_hg_caranteen_safemode:
    local XYplane=get_actual_tool_flange_pose()
    if(XYplane[0]<0 and of_speedbase[0]>0)or(XYplane[0]>0 and of_speedbase[0]<0):
    of_speedbase[0]=0
    end
    if(XYplane[1]<0 and of_speedbase[1]>0)or(XYplane[1]>0 and of_speedbase[1]<0):
    of_speedbase[1]=0
    end
    else:
    of_speedbase=[0,0,0,0,0,0]
    end
    end
    end
    if of_speedl_is_enabled:
    speedl(of_speedbase,a=of_speedl_acc,t=0.001)
    else:
    speedl([0,0,0,0,0,0],a=of_speedl_acc_to_zero,t=0.001)
    end
    end
    if OF_DEBUG_STATE:
    textmsg("Speedl stream ended.")
    end
    end
    def of_speedl_start_for_CMD(start_for_CMD):
    if(start_for_CMD==OF_CMD_LIMIT):
    of_speedl_for_limit=True
    elif(start_for_CMD==OF_CMD_FT_CONTROL):
    of_speedl_for_ft_control=True
    elif(start_for_CMD==OF_CMD_MOVE):
    of_speedl_for_move=True
    elif(start_for_CMD==OF_CMD_HAND_GUIDE):
    of_speedl_for_hand_guide=True
    elif(start_for_CMD==OF_CMD_INSERT_PIN):
    of_speedl_for_insert_pin=True
    elif(start_for_CMD==OF_CMD_GRIPPER_SET_WIDTH):
    of_speedl_for_gripper_set_width=True
    elif(start_for_CMD==OF_CMD_GRIPPER_CENTERING):
    of_speedl_for_gripper_centering=True
    else:
    textmsg("Unknown Start speedl CMD received: ",start_for_CMD)
    end
    local speedl_integer=binary_list_to_integer([of_speedl_for_limit,of_speedl_for_ft_control,of_speedl_for_hand_guide,of_speedl_for_move,of_speedl_for_insert_pin,of_speedl_for_gripper_set_width,of_speedl_for_gripper_centering])
    if not(speedl_integer==0):
    if not of_speedl_is_running:
    of_speedl_thread_handler=run of_speedl_thread()
    end
    end
    return of_speedl_is_running
    end
    def of_speedl_stop_for_CMD(stop_for_CMD,brake=10):
    if(stop_for_CMD==OF_CMD_LIMIT):
    of_speedl_for_limit=False
    elif(stop_for_CMD==OF_CMD_FT_CONTROL):
    of_speedl_for_ft_control=False
    elif(stop_for_CMD==OF_CMD_MOVE):
    of_speedl_for_move=False
    elif(stop_for_CMD==OF_CMD_HAND_GUIDE):
    of_speedl_for_hand_guide=False
    elif(stop_for_CMD==OF_CMD_INSERT_PIN):
    of_speedl_for_insert_pin=False
    elif(stop_for_CMD==OF_CMD_GRIPPER_SET_WIDTH):
    of_speedl_for_gripper_set_width=False
    elif(stop_for_CMD==OF_CMD_GRIPPER_CENTERING):
    of_speedl_for_gripper_centering=False
    else:
    textmsg("Unknown Stop speedl CMD received: ",stop_for_CMD)
    end
    local speedl_integer=binary_list_to_integer([of_speedl_for_limit,of_speedl_for_ft_control,of_speedl_for_hand_guide,of_speedl_for_move,of_speedl_for_insert_pin,of_speedl_for_gripper_set_width,of_speedl_for_gripper_centering])
    if(speedl_integer==0):
    kill of_speedl_thread_handler
    enter_critical
    of_speedl_is_running=False
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("Speedl stream stopped")
    end
    stopl(brake)
    end
    return of_speedl_is_running
    end
  
  
    #======    End of OnRobot Speedl    ======#
  
    #======    OnRobot Acknowledge    ======#
  
    def of_ack_send():
    if OF_DEBUG_STATE:
    textmsg("Acknowledge sending started..")
    end
    of_send_full(OF_CMD_ACK)
    if OF_DEBUG_STATE:
    textmsg("Acknowledge sent")
    end
    end
  
  
    #======    End of OnRobot Acknowledge    ======#
  
    #======    OnRobot Stop Atomic    ======#
  
    def of_stop_atomic(stopLimit=False,stopFTControl=False,stopMove=False,stopHandGuide=False):
    if(not stopLimit)and(not stopFTControl)and(not stopMove)and(not stopHandGuide):
    if OF_DEBUG_STATE:
    textmsg("No atomic command has been stopped.")
    end
    end
    local stopFTControlOrHandGuide=stopFTControl or stopHandGuide
    if OF_DEBUG_STATE:
    textmsg("Stop Atomic sending.. ",[stopLimit,stopFTControl,stopMove,stopHandGuide])
    end
    of_cmd_stop_arg=binary_list_to_integer([stopLimit,stopFTControlOrHandGuide,stopMove])
    of_send_full(OF_CMD_STOP,of_cmd_stop_arg)
    if stopLimit:
    of_speedl_stop_for_CMD(OF_CMD_LIMIT)
    end
    if stopFTControl:
    of_speedl_stop_for_CMD(OF_CMD_FT_CONTROL)
    end
    if stopHandGuide:
    of_speedl_stop_for_CMD(OF_CMD_HAND_GUIDE)
    end
    if stopMove:
    of_speedl_stop_for_CMD(OF_CMD_MOVE)
    end
    if OF_DEBUG_STATE:
    textmsg("Stop Atomic sent: ",of_cmd_stop_arg)
    end
    return of_speedl_is_running
    end
  
  
    #======    End of OnRobot Stop Atomic    ======#
  
    #======    OnRobot Start Atomic    ======#
  
    def of_start_atomic(startLimit=False,startFTControl=False,startMove=False,startHandGuide=False):
    if(not startLimit)and(not startFTControl)and(not startMove)and(not startHandGuide):
    if OF_DEBUG_STATE:
    textmsg("No atomic command has been started.")
    end
    end
    if startLimit:
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (Limit) sending..")
    end
    of_send_full(OF_CMD_START,OF_CMD_LIMIT)
    of_speedl_start_for_CMD(OF_CMD_LIMIT)
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (Limit) sent")
    end
    end
    if startFTControl:
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (FTControl) sending..")
    end
    of_send_full(OF_CMD_START,OF_CMD_FT_CONTROL)
    of_speedl_start_for_CMD(OF_CMD_FT_CONTROL)
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (FTControl) sent")
    end
    end
    if startMove:
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (Move) sending..")
    end
    of_send_full(OF_CMD_START,OF_CMD_MOVE)
    of_speedl_start_for_CMD(OF_CMD_MOVE)
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (Move) sent")
    end
    end
    if startHandGuide:
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (FTControl) sending..")
    end
    of_send_full(OF_CMD_START,OF_CMD_FT_CONTROL)
    of_speedl_start_for_CMD(OF_CMD_HAND_GUIDE)
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (HandGuide) sent")
    end
    end
    return of_speedl_is_running
    end
  
  
    #======    End of OnRobot Start Atomic    ======#
  
    #======    OnRobot F/T Zero    ======#
  
    def of_ft_bias():
    if OF_DEBUG_STATE:
    textmsg("FT Bias sending...")
    end
    of_send_full(OF_CMD_BIAS,0)
    if OF_DEBUG_STATE:
    textmsg("FT Bias sent.")
    end
    end
  
  
    #======    End of OnRobot F/T Zero    ======#
  
    #======    OnRobot TCP    ======#
  
    def of_tcp_offset_calc():
    local act_flange=get_actual_tool_flange_pose()
    local act_tcp=get_actual_tcp_pose()
    local tcp_offset=pose_trans(pose_inv(act_flange),act_tcp)
    return tcp_offset
    end
    def of_tcp_offset_send(TCP_offset):
    if OF_DEBUG_STATE:
    textmsg("TCP Offset sending started!")
    end
    of_send_full(OF_CMD_TCP,of_float_to_int(TCP_offset[0]),of_float_to_int(TCP_offset[1]),of_float_to_int(TCP_offset[2]),of_float_to_int(TCP_offset[3]),of_float_to_int(TCP_offset[4]),of_float_to_int(TCP_offset[5]))
    of_robot_TCP_offset=TCP_offset
    if OF_DEBUG_STATE:
    textmsg("TCP Offset sent.")
    end
    end
    def of_tcp_offset_send_actual():
    if OF_DEBUG_STATE:
    textmsg("Actual TCP Offset sending started!")
    end
    local TCP_offset=of_tcp_offset_calc()
    of_tcp_offset_send(TCP_offset)
    if OF_DEBUG_STATE:
    textmsg("Actual TCP Offset sent.")
    end
    end
    def of_tcp_offset_set(TCP_offset):
    if OF_DEBUG_STATE:
    textmsg("TCP Offset set started!")
    end
    of_tcp_offset_send(TCP_offset)
    set_tcp(TCP_offset)
    of_robot_TCP_offset=TCP_offset
    if OF_DEBUG_STATE:
    textmsg("TCP Offset set to:",of_robot_TCP_offset)
    end
    end
    def of_tcp_offset_rpy_set(offset=[0,0,0],rpy=[0,0,0]):
    if OF_DEBUG_STATE:
    textmsg("TCP Offset RPY set started!")
    end
    local rotvec=rpy2rotvec(rpy)
    local tcp_offset=p[offset[0],offset[1],offset[2],rotvec[0],rotvec[1],rotvec[2]]
    of_tcp_offset_set(tcp_offset)
    if OF_DEBUG_STATE:
    textmsg("TCP Offset RPY set to:",tcp_offset)
    end
    end
  
  
    #======    End of OnRobot TCP    ======#
  
    #======    OnRobot Sensor Config    ======#
  
    of_sensor_flange_offset=ZEROFRAME
    of_sensor_TCP_offset=ZEROFRAME
    def of_sensor_config_send(sensorFlangeOffset=ZEROFRAME,sensorTCPOffset=ZEROFRAME):
    if OF_DEBUG_STATE:
    textmsg("Sensor Config sending started!")
    end
    of_send_full(OF_CMD_SENSOR_CONFIG,of_float_to_int(sensorFlangeOffset[0]),of_float_to_int(sensorFlangeOffset[1]),of_float_to_int(sensorFlangeOffset[2]),of_float_to_int(sensorFlangeOffset[3]),of_float_to_int(sensorFlangeOffset[4]),of_float_to_int(sensorFlangeOffset[5]),of_float_to_int(sensorTCPOffset[0]),of_float_to_int(sensorTCPOffset[1]),of_float_to_int(sensorTCPOffset[2]),of_float_to_int(sensorTCPOffset[3]),of_float_to_int(sensorTCPOffset[4]),of_float_to_int(sensorTCPOffset[5]))
    of_sensor_flange_offset=sensorFlangeOffset
    of_sensor_TCP_offset=of_sensor_TCP_offset
    if OF_DEBUG_STATE:
    textmsg("Sensor Config sent.")
    end
    end
  
  
    #======    End of OnRobot Sensor Config    ======#
  
    #======    OnRobot Payload    ======#
  
    of_robot_mount=[0,0]
    of_center_of_gravity=[0,0,0]
    of_payload_mass=0
    def of_robot_mount_set(robot_mount=[0,0]):
    if OF_DEBUG_STATE:
    textmsg("Robot mount set started!")
    end
    of_robot_mount=robot_mount
    if OF_DEBUG_STATE:
    textmsg("Robot mount has been set to:",robot_mount)
    end
    end
    def of_payload_set(mass=0,center_of_gravity=[0,0,0]):
    if OF_DEBUG_STATE:
    textmsg("Robot mount, Center of Gravity & Payload sending started!")
    end
    robot_mount=of_robot_mount
    of_send_full(OF_CMD_PAYLOAD,of_float_to_int(robot_mount[0]),of_float_to_int(robot_mount[1]),of_float_to_int(mass),of_float_to_int(center_of_gravity[0]),of_float_to_int(center_of_gravity[1]),of_float_to_int(center_of_gravity[2]))
    set_payload(mass,center_of_gravity)
    of_center_of_gravity=center_of_gravity
    of_payload_mass=mass
    if OF_DEBUG_STATE:
    textmsg("Robot mount, Center of Gravity & Payload sent.")
    end
    end
  
  
    #======    End of OnRobot Payload    ======#
  
    #======    OnRobot Gripper Mount Messages    ======#
  
  
  
    #======    End of OnRobot Gripper Mount Messages    ======#
  
    #======    OnRobot Gripper Mount    ======#
  
    def of_gripper_mount_send(gripper_offset):
    sync()
    if OF_DEBUG_STATE:
    textmsg("Gripper Mount Send command starting..")
    end
    of_send_full(OF_CMD_GRIPPER_MOUNT,of_float_to_int(gripper_offset[0]),of_float_to_int(gripper_offset[1]),of_float_to_int(gripper_offset[2]),of_float_to_int(gripper_offset[3]),of_float_to_int(gripper_offset[4]),of_float_to_int(gripper_offset[5]))
    if OF_DEBUG_STATE:
    textmsg("Gripper Mount Send command ended.")
    end
    end
  
  
    #======    End of OnRobot Gripper Mount    ======#
  
    #======    OnRobot Gripper Part TCP Messages    ======#
  
    of_gripper_tcp_set_done="OnRobot: TCP set to the RG2-FT fingertip center."
  
  
    #======    End of OnRobot Gripper Part TCP Messages    ======#
  
    #======    OnRobot Gripper Part TCP    ======#
  
    of_gripper_gripperSingleOffset=39.0
    of_gripper_mounting_qc_offset=p[0,0,0.0241,0,0,-0.39270]
    of_gripper_mounting_qc_cog=p[0,0,0.01205,0,0,0]
    of_gripper_mounting_qc_mass=0.202
    of_gripper_mount_offset=p[0,0,0,0,0,0]
    of_gripper_mounted_cog=p[0,0,0,0,0,0]
    of_gripper_mounting_single_mass=0.088
    of_gripper_bodyEndOffsetZ=-30.0+118.0
    of_gripper_pivotCenterOffsetY=-2.3
    of_gripper_pivotCenterOffsetZ=26.8
    of_gripper_sensorCenterOffsetZ=-7.6
    of_gripper_armLength=55.0
    of_gripper_bodyDepthZSum=of_gripper_bodyEndOffsetZ+of_gripper_pivotCenterOffsetZ+of_gripper_sensorCenterOffsetZ
    of_gripper_bodyCOGOffsetZ=-30.0
    of_gripper_bodyCOGZ=of_gripper_bodyEndOffsetZ+of_gripper_bodyCOGOffsetZ
    of_gripper_mass=0.770
    of_gripper_body_cog=p[0,0,(of_gripper_bodyCOGZ/1000),0,0,0]
    of_gripper_mounted_mass=of_gripper_mass
    of_gripper_follow_tcp=False
    of_gripper_follow_tcp_offset=p[0,0,0,0,0,0]
    of_gripper_follow_cog=False
    of_gripper_follow_cog_offset=[0,0,0]
    def of_gripper_mount_single(mount_angle,gripper_angle):
    if OF_DEBUG_STATE:
    textmsg("Gripper Mount Single command starting..")
    end
    local gripper_rotvec=rpy2rotvec([0,gripper_angle,mount_angle])
    local gripper_mount_offset=p[0,0,of_gripper_gripperSingleOffset/1000.0,gripper_rotvec[0],gripper_rotvec[1],gripper_rotvec[2]]
    local gripper_offset=pose_trans(of_gripper_bracket_offset,gripper_mount_offset)
    of_gripper_mounted_mass=of_gripper_mounted_mass+of_gripper_mounting_single_mass
    of_gripper_mount_offset=gripper_offset
    of_gripper_mounted_cog=pose_trans(of_gripper_mount_offset,of_gripper_body_cog)
    if OF_DEBUG_STATE:
    textmsg("Gripper Mount Single command ended.")
    end
    return gripper_offset
    end
    def of_gripper_mount_qc10():
    if OF_DEBUG_STATE:
    textmsg("Gripper Mount QC10 command starting..")
    end
    of_gripper_mounted_mass=of_gripper_mounted_mass+of_gripper_mounting_qc_mass
    local mass_ratio=of_gripper_mounting_qc_mass/of_gripper_mounted_mass
    local mounted_cog=pose_trans(of_gripper_mounting_qc_offset,of_gripper_mounted_cog)
    local gripper_mounted_cog=p[mounted_cog[0],mounted_cog[1],mounted_cog[2],0,0,0]
    of_gripper_mounted_cog=interpolate_pose(gripper_mounted_cog,of_gripper_mounting_qc_cog,mass_ratio)
    local gripper_offset=pose_trans(of_gripper_mounting_qc_offset,of_gripper_mount_offset)
    local mount_offset=pose_trans(of_gripper_qc_offset,gripper_offset)
    of_gripper_mount_offset=mount_offset
    local qc_additional_offset=pose_trans(of_gripper_qc_offset,of_gripper_mounting_qc_offset)
    if OF_DEBUG_STATE:
    textmsg("Gripper Mount QC10 command ended.")
    end
    return qc_additional_offset
    end
    def of_gripper_fcp_depth_calc(gripperWidth):
    local d2=gripperWidth/2.0-of_gripper_pivotCenterOffsetY
    local alpha=asin(d2/of_gripper_armLength)
    local gripperDepth=of_gripper_armLength*cos(alpha)+of_gripper_bodyDepthZSum
    return gripperDepth
    end
    def of_gripper_fcp_part_offset_calc(gripperWidth,part_offset=p[0,0,0,0,0,0]):
    local gripperDepth=of_gripper_fcp_depth_calc(gripperWidth)
    local gripper_fcp_pose=pose_trans(of_gripper_mount_offset,p[0.0,0.0,gripperDepth/1000.0,0,0,0])
    local offset_pose=gripper_fcp_pose
    if not(part_offset==p[0,0,0,0,0,0]):
    offset_pose=pose_trans(gripper_fcp_pose,part_offset)
    end
    return offset_pose
    end
    def of_gripper_tcp_update():
    local part_offset=of_gripper_follow_tcp_offset
    local tcp_offset=of_gripper_fcp_part_offset_calc(rg_Width,part_offset)
    of_tcp_offset_set(tcp_offset)
    return tcp_offset
    end
    def of_gripper_part_offset_set(length,angle):
    local finger_rotation=rpy2rotvec([0,angle,0])
    local part_rotation=p[0,0,0,finger_rotation[0],finger_rotation[1],finger_rotation[2]]
    local fingertip_offset=of_gripper_fcp_part_offset_calc(rg_Width,part_rotation)
    local part_offset=p[0,0,length,0,0,0]
    tcp_offset=pose_trans(fingertip_offset,part_offset)
    of_tcp_offset_set(tcp_offset)
    return tcp_offset
    end
    def of_gripper_relative_offset_set(part_offset):
    if OF_DEBUG_STATE:
    textmsg("Gripper fingertip-relative TCP Offset set started!")
    end
    enter_critical
    of_gripper_follow_tcp_offset=part_offset
    exit_critical
    local tcp_offset=of_gripper_fcp_part_offset_calc(rg_Width,part_offset)
    of_tcp_offset_set(tcp_offset)
    if OF_DEBUG_STATE:
    textmsg("Gripper fingertip-relative TCP Offset set to: ",tcp_offset)
    end
    return tcp_offset
    end
    def of_gripper_relative_rpy_offset_set(offset=[0,0,0],rpy=[0,0,0]):
    if OF_DEBUG_STATE:
    textmsg("Gripper fingertip-relative TCP Offset RPY set started!")
    end
    local rotvec=rpy2rotvec(rpy)
    local tool_offset=p[offset[0],offset[1],offset[2],rotvec[0],rotvec[1],rotvec[2]]
    local tcp_offset=of_gripper_relative_offset_set(tool_offset)
    if OF_DEBUG_STATE:
    textmsg("Gripper fingertip-relative TCP Offset RPY set to: ",tcp_offset)
    end
    return tcp_offset
    end
    def of_gripper_follow_tcp_set(follow):
    if OF_DEBUG_STATE:
    textmsg("Gripper fingertip-relative TCP Offset follow set started!")
    end
    enter_critical
    of_gripper_follow_tcp=follow
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("Gripper fingertip-relative TCP Offset follow set to: ",follow)
    end
    end
    def of_gripper_compensated_relative_payload_set(part_mass=0,center_of_gravity=[0,0,0]):
    if OF_DEBUG_STATE:
    textmsg("Gripper fingertip-relative Payload set started!")
    end
    local gripperWidth=rg_Width
    local part_cog_offset=p[center_of_gravity[0],center_of_gravity[1],center_of_gravity[2],0,0,0]
    local mass_ratio=of_gripper_mounted_mass/(part_mass+of_gripper_mounted_mass)
    local gripper_fcp_pose=of_gripper_fcp_part_offset_calc(gripperWidth)
    local part_cog=pose_trans(gripper_fcp_pose,part_cog_offset)
    local cog_pose=interpolate_pose(part_cog,of_gripper_mounted_cog,mass_ratio)
    local cog_relative=pose_trans(pose_inv(gripper_fcp_pose),cog_pose)
    cog=[cog_pose[0],cog_pose[1],cog_pose[2]]
    mass= part_mass+of_gripper_mounted_mass
    of_payload_set(mass=mass,center_of_gravity=cog)
    enter_critical
    of_gripper_follow_cog_offset=[cog_relative[0],cog_relative[1],cog_relative[2]]
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("Gripper compensated fingertip-relative Payload set to: ",cog)
    end
    return cog
    end
    def of_gripper_relative_payload_set(mass=0,center_of_gravity=[0,0,0]):
    if OF_DEBUG_STATE:
    textmsg("Gripper fingertip-relative Payload set started!")
    end
    local gripperWidth=rg_Width
    local part_cog_offset=p[center_of_gravity[0],center_of_gravity[1],center_of_gravity[2],0,0,0]
    local cog_pose=of_gripper_fcp_part_offset_calc(gripperWidth,part_cog_offset)
    local cog=[cog_pose[0],cog_pose[1],cog_pose[2]]
    of_payload_set(mass=mass,center_of_gravity=cog)
    enter_critical
    of_gripper_follow_cog_offset=center_of_gravity
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("Gripper compensated fingertip-relative Payload set to: ",center_of_gravity)
    end
    return cog
    end
    def of_gripper_cog_update():
    enter_critical
    local part_cog=of_gripper_follow_cog_offset
    exit_critical
    local cog=of_gripper_relative_payload_set(mass=of_payload_mass,center_of_gravity=part_cog)
    return cog
    end
    def of_gripper_follow_cog_set(follow):
    if OF_DEBUG_STATE:
    textmsg("Gripper fingertip-relative TCP Offset follow set started!")
    end
    enter_critical
    of_gripper_follow_cog=follow
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("Gripper fingertip-relative TCP Offset follow set to: ",follow)
    end
    end
  
  
    #======    End of OnRobot Gripper Part TCP    ======#
  
    #======    OnRobot Engine Start    ======#
  
    of_RPC=rpc_factory("xmlrpc","http://127.0.0.1:33000")
    of_compute_engine_IP=of_sensor_IP
    textmsg(of_engine_start_ip,of_compute_engine_IP)
    of_sg_thrd=run of_safeguard_thread()
    sync()
    of_portopen_controlSocket()
    sync()
    of_portopen_vectorStream()
    sync()
    of_vectorStream_thrd=run of_vectorStream_thread()
    sync()
    of_vectorProcess_thrd=run of_vectorProcess_thread()
    sync()
    of_portopen_commandFlow()
    sync()
    of_cmd_thrd=run of_commandFlow_thread()
    sync()
    sync()
    while(of_sensor_id==OF_SENSOR_ID_UNDEFINED):
    sync()
    end
  
    local gripper_mount=of_gripper_mount_single(d2r(of_mounting_bracket_angle),d2r(of_mounting_gripper_angle))
    of_gripper_mount_send(gripper_mount)
    local mount_offset=of_gripper_qc_offset
    if(of_mounting_qc_use):
    mount_offset=of_gripper_mount_qc10()
    end
    of_sensor_config_send(mount_offset)
    if(of_install_tcp):
    of_gripper_follow_tcp_set(of_gripper_follow_fingertip)
    of_gripper_relative_rpy_offset_set(offset=of_gripper_part_tcp_offset_xyz,rpy=of_gripper_part_tcp_offset_rpy)
    of_gripper_follow_cog_set(of_gripper_follow_fingertip)
    if(of_gripper_install_cog2tcp):
    local cog_mass=of_gripper_part_cog_mass+of_gripper_mounted_mass
    of_gripper_relative_payload_set(mass=cog_mass,center_of_gravity=of_gripper_part_cog_offset)
    else:
    of_gripper_compensated_relative_payload_set(part_mass=of_gripper_part_cog_mass,center_of_gravity=of_gripper_part_cog_offset)
    end
    end
  
    of_tcp_offset_send_actual()
    of_ft_bias()
  
  
    #======    End of OnRobot Engine Start    ======#
  
    #======    OnRobot F/T Limit    ======#
  
    def of_limit_start(ft_select=FALSE8D,ft_limits=[0,0,0,0,0,0,0,0],ft_abs=FALSE6D,timeout=0,v_min=0,frameID=0,frameRPY=[0,0,0],forFTControl=False,popupmsg=True):
    local binary_list=integer_to_binary_list(0)
    local iBin=0
    while iBin<15:
    if iBin<6:
    binary_list[iBin]=ft_abs[iBin]
    elif iBin<(6+8):
    binary_list[iBin]=ft_select[iBin-6]
    elif iBin==14:
    binary_list[iBin]=forFTControl
    else:
    sync()
    end
    iBin=iBin+1
    end
    local int_bool_list=binary_list_to_integer(binary_list)
    local frame_rotvec=rpy2rotvec(frameRPY)
    of_send_full(OF_CMD_LIMIT,of_float_to_int(ft_limits[0]),of_float_to_int(ft_limits[1]),of_float_to_int(ft_limits[2]),of_float_to_int(ft_limits[3]),of_float_to_int(ft_limits[4]),of_float_to_int(ft_limits[5]),of_float_to_int(ft_limits[6]),of_float_to_int(ft_limits[7]),int_bool_list,of_float_to_int(timeout),of_float_to_int(v_min),frameID,of_float_to_int(frame_rotvec[0]),of_float_to_int(frame_rotvec[1]),of_float_to_int(frame_rotvec[2]))
    end
    def of_limit_stop(forFTControl=False):
    of_stop_atomic(stopLimit=True)
    end
  
  
    #======    End of OnRobot F/T Limit    ======#
  
    #======    OnRobot F/T Control Messages    ======#
  
    of_ft_control_title="OnRobot - F/T Control"
    of_ft_control_start_error="Do not include a F/T Control command under another F/T Control command."
  
  
    #======    End of OnRobot F/T Control Messages    ======#
  
    #======    OnRobot F/T Control    ======#
  
    of_ft_control_state=0
    of_ft_control_return=0
    OF_FT_CONTROL_STATE_IDLE=0
    OF_FT_CONTROL_STATE_RUNNING=1
    def of_ft_control_start(ft_select=FALSE6D,ft_values=[0.0,0.0,0.0,0.0,0.0,0.0],frameID=0,frameRPY=[0,0,0],forcePID=[1.0,0.0,0.0],torquePID=[1.0,0.0,0.0],deviation_max=0):
    if not(of_ft_control_state==OF_FT_CONTROL_STATE_IDLE):
    textmsg("of_ft_control_state: ",of_ft_control_state)
    popup(of_ft_control_start_error,title=of_ft_control_title,error=True,blocking=False)
    halt
    else:
    of_ft_control_state=OF_FT_CONTROL_STATE_RUNNING
    end
    of_tcp_offset_send_actual()
    local flags=binary_list_to_integer(ft_select)+(frameID*64)
    local frame_rotvec=rpy2rotvec(frameRPY)
    if OF_DEBUG_STATE:
    textmsg("Start force mode")
    end
    of_send_full(OF_CMD_FT_CONTROL,of_float_to_int(ft_values[0]),of_float_to_int(ft_values[1]),of_float_to_int(ft_values[2]),of_float_to_int(ft_values[3]),of_float_to_int(ft_values[4]),of_float_to_int(ft_values[5]),flags,of_float_to_int(frame_rotvec[0]),of_float_to_int(frame_rotvec[1]),of_float_to_int(frame_rotvec[2]),of_float_to_int(forcePID[0]),of_float_to_int(forcePID[1]),of_float_to_int(forcePID[2]),of_float_to_int(torquePID[0]),of_float_to_int(torquePID[1]),of_float_to_int(torquePID[2]),of_float_to_int(deviation_max))
    of_speedl_start_for_CMD(OF_CMD_FT_CONTROL)
    if frameID==0 or frameID==1 or frameID==2 or frameID==3:
    of_parent_of_move_frameID=frameID
    of_parent_of_move_frame=p[0,0,0,frame_rotvec[0],frame_rotvec[1],frame_rotvec[2]]
    else:
    of_parent_of_move_frameID=0
    of_parent_of_move_frame=ZEROFRAME
    end
    if OF_DEBUG_STATE:
    textmsg("FT Control started")
    end
    end
    def of_ft_control_stop():
    of_stop_atomic(stopFTControl=True)
    of_ft_control_state=OF_FT_CONTROL_STATE_IDLE
    of_parent_of_move_frameID=0
    of_parent_of_move_frame=ZEROFRAME
    end
  
  
    #======    End of OnRobot F/T Control    ======#
  
    #======    OnRobot Hand Guide Messages    ======#
  
    of_hand_guide_title="OnRobot - Hand Guide"
    of_hand_guide_error_high_ft="Too high forces. Hand Guide stopped."
    of_hand_guide_error_singularity="The tool flange is too close to a singularity. Hand Guide stopped."
    of_hand_guide_safemode_enter="The tool flange is too close to the Base Z-axis singularity. Hand Guide is in Safe mode."
    of_hand_guide_start_error="Do not include a Hand Guide command under another Hand Guide command."
    of_hand_guide_safemode_exit="Hand Guide Safe mode ended."
  
  
    #======    End of OnRobot Hand Guide Messages    ======#
  
    #======    OnRobot Hand Guide    ======#
  
    of_hg_enable_HandGuide=True
    of_hand_guide_state=0
    of_hg_enable_axes=FALSE6D
    of_hg_axisZ_extra_dist=0
    of_hg_axisZ_min_dist=0
    of_hg_axisZ_dist=0
    of_hg_TMB_dist=0
    of_hg_joints_min_dev=0
    of_hg_stop_F=0
    of_hg_stop_T=0
    of_hg_joints_min_dev=d2r(0.5)
    of_hg_axisZ_extra_dist=0.06
    if of_robot_type==10:
    if OF_DEBUG_STATE:
    textmsg("Robot type UR10 set")
    end
    of_hg_axisZ_min_dist=0.163941
    of_hg_TMB_dist=0.0922
    elif of_robot_type==5:
    if OF_DEBUG_STATE:
    textmsg("Robot type UR5 set")
    end
    of_hg_axisZ_min_dist=0.10915
    of_hg_TMB_dist=0.0823
    elif of_robot_type==3:
    if OF_DEBUG_STATE:
    textmsg("Robot type UR3 set")
    end
    of_hg_axisZ_min_dist=0.11235
    of_hg_TMB_dist=0.0819
    elif of_robot_type==0:
    if OF_DEBUG_STATE:
    textmsg("Robot type not set: do not use caranteen")
    end
    of_hg_axisZ_min_dist=0
    of_hg_TMB_dist=0.0
    else:
    if OF_DEBUG_STATE:
    textmsg("Unknown robot type, using UR10 parameters; Type: ",of_robot_type)
    end
    of_hg_axisZ_min_dist=0.163941
    of_hg_TMB_dist=0.0922
    end
    of_hg_axisZ_dist=of_hg_axisZ_min_dist+of_hg_axisZ_extra_dist
    OF_HAND_GUIDE_STATE_IDLE=0
    OF_HAND_GUIDE_STATE_RUNNING=1
    def of_hand_guide_start(axes_en=FALSE6D,thresholdF=15,thresholdT=0.6,saturationV=0.6,saturationW=0.2,stopF=100,stopT=5,PGainF=0.15,PGainT=0.15,IGainF=0,IGainT=0,DGainF=0.01,DGainT=0.01):
    if OF_DEBUG_STATE:
    textmsg("Starting hand guide")
    end
    if not(of_hand_guide_state==OF_HAND_GUIDE_STATE_IDLE or of_hand_guide_state==OF_HAND_GUIDE_STATE_RUNNING):
    textmsg("of_hand_guide_state: ",of_hand_guide_state)
    popup(of_hand_guide_start_error,title=of_hand_guide_title,error=True,blocking=False)
    halt
    else:
    of_hand_guide_state=OF_HAND_GUIDE_STATE_RUNNING
    end
    of_tcp_offset_send_actual()
    local Axes_en=binary_list_to_integer(axes_en)
    if OF_DEBUG_VAR:
    textmsg("Axes_en: ",Axes_en)
    end
    of_hg_stop_F=stopF
    of_hg_stop_T=stopT
    of_send_full(OF_CMD_HAND_GUIDE,Axes_en,of_float_to_int(thresholdF),of_float_to_int(thresholdT),of_float_to_int(saturationV),of_float_to_int(saturationW),of_float_to_int(stopF),of_float_to_int(stopT),of_float_to_int(PGainF),of_float_to_int(PGainT),of_float_to_int(IGainF),of_float_to_int(IGainT),of_float_to_int(DGainF),of_float_to_int(DGainT))
    of_speedl_start_for_CMD(OF_CMD_HAND_GUIDE)
    if OF_DEBUG_STATE:
    textmsg("HandGuide started")
    end
    end
    def of_hand_guide_stop():
    of_stop_atomic(stopHandGuide=True)
    of_hand_guide_state=OF_HAND_GUIDE_STATE_IDLE
    of_parent_of_move_frameID=0
    of_parent_of_move_frame=ZEROFRAME
    end
    def of_hg_stop_limit_reached():
    local is_reached=False
    if(of_hg_enable_axes[0]and(Fx>of_hg_stop_F)):
    is_reached=True
    elif(of_hg_enable_axes[1]and(Fy>of_hg_stop_F)):
    is_reached=True
    elif(of_hg_enable_axes[2]and(Fz>of_hg_stop_F)):
    is_reached=True
    elif(of_hg_enable_axes[3]and(Tx>of_hg_stop_T)):
    is_reached=True
    elif(of_hg_enable_axes[4]and(Ty>of_hg_stop_T)):
    is_reached=True
    elif(of_hg_enable_axes[5]and(Tz>of_hg_stop_T)):
    is_reached=True
    end
    return is_reached
    end
    def of_hg_stop_area_reached():
    local is_reached=False
    local Zzero=p[0,0,0,0,0,0]
    local XYplane=p[0,0,0,0,0,0]
    local act_flange=get_actual_tool_flange_pose()
    local act_joints=get_actual_joint_positions()
    XYplane[0]=act_flange[0]
    XYplane[1]=act_flange[1]
    local qWrist2=act_joints[4]%MATH_PI
    local dist2Z=point_dist(XYplane,Zzero)
    local dist2Z_min=of_hg_axisZ_dist+(of_hg_TMB_dist*cos(act_joints[4]))
    if(dist2Z<dist2Z_min):
    of_speedl_hg_caranteen_reached=True
    elif(dist2Z>dist2Z_min+0.01):
    of_speedl_hg_caranteen_reached=False
    if of_speedl_hg_caranteen_safemode:
    of_speedl_hg_caranteen_safemode=False
    textmsg(of_hand_guide_safemode_exit)
    end
    end
    if(norm(qWrist2)<of_hg_joints_min_dev):
    is_reached=True
    end
    return is_reached
    end
    def of_hand_guide_run():
    while of_hg_enable_HandGuide:
    if(of_hg_stop_limit_reached()):
    popup(of_hand_guide_error_high_ft,title=of_hand_guide_title,error=True,blocking=False)
    of_hg_enable_HandGuide=False
    elif(of_hg_stop_area_reached()):
    popup(of_hand_guide_error_singularity,title=of_hand_guide_title,warning=True,blocking=False)
    of_hg_enable_HandGuide=False
    elif(of_speedl_hg_caranteen_reached and(not of_speedl_hg_caranteen_safemode)):
    popup(of_hand_guide_safemode_enter,title=of_hand_guide_title,warning=True,blocking=True)
    of_speedl_hg_caranteen_safemode=True
    else:
    sync()
    end
    end
    end
  
  
    #======    End of OnRobot Hand Guide    ======#
  
    #======    OnRobot F/T Move  F/T Search Messages    ======#
  
    of_move_error_title="OnRobot - F/T Move error"
    of_search_error_title="OnRobot - F/T Search error"
    of_move_init_error="Wrong F/T Move or F/T Search status when initializing.<br>Another thread is using an F/T Move or F/T Search command. Program stopped."
    of_move_start_error="Wrong F/T Move or F/T Search status when starting.<br>Another thread is using an F/T Move or F/T Search command. Program stopped."
    of_move_return_error="Wrong F/T Move or F/T Search status when returning.<br>Another thread is using an F/T Move or F/T Search command. Program stopped."
    of_move_parameter_error_count="Parameter error.<br>Incorrect use of F/T Waypoint or F/T Path in the F/T Move or F/T Search command. Program stopped."
    of_move_move_return_title="OnRobot - F/T Move"
    of_move_move_return_0="The move ended without detecting a force or torque greater than the set limit."
    of_move_move_return_1="The move ended, because a force or torque greater than the set limit was detected."
    of_move_move_return_2="The move cannot start due to a force or torque exceeding the set limit."
    of_move_move_return_3="The move was interrupted by a command."
    of_move_move_return_11="The move cannot start, because there is no recorded path on the Compute Box with the selected ID."
    of_move_move_return_12="The move cannot start, because there are no recorded points in this Path."
    of_move_move_return_13="The move cannot start, because the Path file found at this Path ID is empty."
    of_move_move_return_14="The move cannot start, because the Path file is corrupted."
    of_move_move_return_unknown="F/T Move finished with unknown return value."
    of_move_search_return_title="OnRobot - F/T Search"
    of_move_search_return_0="The search ended successfully, because a force or torque greater than the set limit was detected."
    of_move_search_return_1="The search ended without detecting a force or torque greater than the set limit."
    of_move_search_return_2="The search cannot start due to a force or torque exceeding the set limit."
    of_move_search_return_3="The search was interrupted by a command."
    of_move_search_return_11="The search cannot start, because there is no recorded path on the Compute Box with the selected ID."
    of_move_search_return_12="The search cannot start, because there are no recorded points in this Path."
    of_move_search_return_13="The search cannot start, because the Path file found at this Path ID is empty."
    of_move_search_return_14="The search cannot start, because the Path file is corrupted."
    of_move_search_return_unknown="F/T Search finished with unknown return value."
  
  
    #======    End of OnRobot F/T Move & F/T Search Messages    ======#
  
    #======    OnRobot F/T Move  F/T Search    ======#
  
    of_move_state=0
    of_move_return=0
    of_move_frameID=0
    of_move_frame=ZEROFRAME
    of_move_last_pose=ZEROPOSE
    of_move_min_dist=0
    of_move_wp_count=0
    of_move_path_count=0
    of_move_path_move_home=False
    of_move_min_dist=0.001
    OF_MOVE_STATE_IDLE=0
    OF_MOVE_STATE_INIT=1
    OF_MOVE_STATE_GLOBALS_SET=2
    OF_MOVE_STATE_PARAM_SEND=3
    OF_MOVE_STATE_PARAM_SENT=4
    OF_MOVE_STATE_INITED=5
    OF_MOVE_STATE_STARTING=6
    OF_MOVE_STATE_WP_SENT=7
    OF_MOVE_STATE_STARTED=8
    OF_MOVE_STATE_RETURNING=9
    OF_MOVE_STATE_FINISHED=10
    OF_MOVE_STATE_STOPPING=11
    OF_MOVE_STATE_PATH_STOPPED=12
    of__move_parameter_error_coordsys="Parameter error.<br>Unknown coordinate system. Program stopped."
    of__move_parameter_error_speed="Parameter error.<br>Invalid value for the speed parameter. Program stopped."
    of__move_parameter_error_acc="Parameter error.<br>Invalid value for the acc parameter. Program stopped."
    def of_move_init(frameID=0,frameRPY=[0,0,0],speed=0.05,acc=1.2,scale=False,move2First=True,move21Last=True):
    sync()
    if not(of_move_state==OF_MOVE_STATE_IDLE):
    textmsg("of_move_state: ",of_move_state)
    popup(of_move_init_error,title=of_move_error_title,error=True,blocking=False)
    halt
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_INIT
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("FT Move initializing..")
    end
    if not(speed>0):
    popup(of__move_parameter_error_speed,title=of_move_error_title,error=True,blocking=False)
    halt
    elif not(acc>0):
    popup(of__move_parameter_error_acc,title=of_move_error_title,error=True,blocking=False)
    halt
    else:
    sync()
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_GLOBALS_SET
    exit_critical
    of_tcp_offset_send_actual()
    of_move_frameID=frameID
    if frameID==0 or frameID==1:
    of_move_frame=ZEROFRAME
    elif frameID==2 or frameID==3:
    frame_rotvec=rpy2rotvec(frameRPY)
    of_move_frame=p[0,0,0,frame_rotvec[0],frame_rotvec[1],frame_rotvec[2]]
    elif frameID==4:
    parentID=of_parent_of_move_frameID
    if parentID==0 or parentID==1 or parentID==2 or parentID==3:
    of_move_frameID=of_parent_of_move_frameID
    of_move_frame=of_parent_of_move_frame
    else:
    textmsg("Invalid of_parent_of_move_frameID, frame set to Base. Invalid ID: ",of_parent_of_move_frameID)
    of_parent_of_move_frameID=0
    of_parent_of_move_frame=ZEROFRAME
    of_move_frameID=of_parent_of_move_frameID
    of_move_frame=of_parent_of_move_frame
    end
    sync()
    else:
    popup(of__move_parameter_error_coordsys,title=of_move_error_title,error=True,blocking=False)
    halt
    end
    of_move_path_move_home=False
    of_move_path_count=0
    of_move_wp_count=0
    of_move_last_pose=get_actual_tcp_pose()
    local flags=binary_list_to_integer([scale,move2First,move21Last])
    enter_critical
    of_move_state=OF_MOVE_STATE_PARAM_SEND
    exit_critical
    of_send_full(OF_CMD_MOVE,of_float_to_int(speed),of_float_to_int(acc),of_move_frameID,of_float_to_int(of_move_frame[3]),of_float_to_int(of_move_frame[4]),of_float_to_int(of_move_frame[5]),flags)
    enter_critical
    of_move_state=OF_MOVE_STATE_PARAM_SENT
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("FT Move initialized")
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_INITED
    exit_critical
    sync()
    end
    def of_move_start_move(popupmsg=True):
    sync()
    if(of_move_state==OF_MOVE_STATE_PATH_STOPPED):
    sync()
    elif not(of_move_state==OF_MOVE_STATE_INITED):
    textmsg("of_move_state: ",of_move_state)
    popup(of_move_start_error,title=of_move_error_title,error=True,blocking=False)
    halt
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_STARTING
    exit_critical
    if not(of_move_wp_count>0 or of_move_path_count==1):
    textmsg("[Waypoint#, Path#]: ",[of_move_wp_count,of_move_path_count])
    popup(of_move_parameter_error_count,title=of_move_error_title,error=True,blocking=False)
    halt
    else:
    sync()
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_WP_SENT
    exit_critical
    of_start_atomic(startMove=True)
    if OF_DEBUG_STATE:
    textmsg("FT Move started")
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_STARTED
    exit_critical
    of_move_return=of_wait_for_return(OF_CMD_MOVE,True)
    of_speedl_stop_for_CMD(OF_CMD_MOVE)
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_FINISHED
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("FT Move finished with return value: ",of_move_return)
    end
    if of_move_return==0:
    elif of_move_return==1:
    if popupmsg:
    popup(of_move_move_return_1,title=of_move_move_return_title,warning=True,blocking=True)
    end
    elif of_move_return==3:
    if popupmsg:
    popup(of_move_move_return_3,title=of_move_move_return_title,warning=True,blocking=True)
    end
    elif of_move_return==11:
    popup(of_move_move_return_11,title=of_move_move_return_title,warning=True,blocking=True)
    elif of_move_return==12:
    popup(of_move_move_return_12,title=of_move_move_return_title,warning=True,blocking=True)
    elif of_move_return==13:
    popup(of_move_move_return_13,title=of_move_move_return_title,warning=True,blocking=True)
    elif of_move_return==14:
    popup(of_move_move_return_14,title=of_move_move_return_title,warning=True,blocking=True)
    else:
    popup(of_move_move_return_unknown,title=of_move_move_return_title,warning=True,blocking=True)
    end
    if(of_move_path_move_home):
    if(of_move_return==0):
    enter_critical
    of_move_state=OF_MOVE_STATE_INITED
    exit_critical
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_PATH_STOPPED
    exit_critical
    end
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_IDLE
    exit_critical
    end
    sync()
    return of_move_return
    end
    def of_move_start_search(popupmsg=True):
    sync()
    if(of_move_state==OF_MOVE_STATE_PATH_STOPPED):
    sync()
    elif not(of_move_state==OF_MOVE_STATE_INITED):
    textmsg("of_move_state: ",of_move_state)
    popup(of_move_start_error,title=of_search_error_title,error=True,blocking=False)
    halt
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_STARTING
    exit_critical
    if not(of_move_wp_count>0 or of_move_path_count==1):
    textmsg("[Waypoint#, Path#]: ",[of_move_wp_count,of_move_path_count])
    popup(of_move_parameter_error_count,title=of_search_error_title,error=True,blocking=False)
    halt
    else:
    sync()
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_WP_SENT
    exit_critical
    of_start_atomic(startMove=True)
    if OF_DEBUG_STATE:
    textmsg("FT Move started")
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_STARTED
    exit_critical
    of_move_return=of_wait_for_return(OF_CMD_MOVE,True)
    of_speedl_stop_for_CMD(OF_CMD_MOVE)
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_FINISHED
    exit_critical
    local of_search_return=of_move_return
    if of_move_return==0:
    of_search_return=1
    elif of_move_return==1:
    of_search_return=0
    end
    if OF_DEBUG_STATE:
    textmsg("FT Search finished with return value: ",of_search_return)
    end
    if of_search_return==0:
    elif of_search_return==1:
    if popupmsg:
    popup(of_move_search_return_1,title=of_move_search_return_title,warning=True,blocking=True)
    end
    elif of_search_return==3:
    if popupmsg:
    popup(of_move_search_return_3,title=of_move_search_return_title,warning=True,blocking=True)
    end
    elif of_search_return==11:
    popup(of_move_search_return_11,title=of_move_search_return_title,warning=True,blocking=True)
    elif of_search_return==12:
    popup(of_move_search_return_12,title=of_move_search_return_title,warning=True,blocking=True)
    elif of_search_return==13:
    popup(of_move_search_return_13,title=of_move_search_return_title,warning=True,blocking=True)
    elif of_search_return==14:
    popup(of_move_search_return_14,title=of_move_search_return_title,warning=True,blocking=True)
    else:
    popup(of_move_search_return_unknown,title=of_move_search_return_title,warning=True,blocking=True)
    end
    if(of_move_path_move_home):
    if(of_move_return==0):
    enter_critical
    of_move_state=OF_MOVE_STATE_INITED
    exit_critical
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_PATH_STOPPED
    exit_critical
    end
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_IDLE
    exit_critical
    end
    sync()
    return of_search_return
    end
    def of_move_limit_return(limit_return):
    if limit_return==0:
    of_move_return=0
    elif limit_return==1:
    of_move_return=1
    else:
    of_move_return=2
    if OF_DEBUG_STATE:
    textmsg("FT Move returned with limit_return: ",limit_return)
    end
    end
    end
    def of_move_stop():
    if of_move_state==OF_MOVE_STATE_IDLE:
    textmsg("No move command has been stopped")
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_STOPPING
    exit_critical
    of_wait_for_return_stop(OF_CMD_MOVE)
    of_stop_atomic(stopMove=True)
    of_move_return=of_wait_for_return(OF_CMD_MOVE,True)
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_IDLE
    exit_critical
    end
  
  
    #======    End of OnRobot F/T Move & F/T Search    ======#
  
    #======    OnRobot F/T Waypoint Messages    ======#
  
    of_waypoint_error_title="OnRobot - F/T Waypoint error"
    of_waypoint_move_state_error="Wrong program structure when initializing F/T Waypoint.<br>Program stopped.<br>Make sure that the F/T Waypoint is under F/T Move or F/T Search."
    of_waypoint_path_count_error="Incorrect use of F/T Waypoint.<br>Do not use F/T Waypoint and F/T Path in the same F/T Move or F/T Search.<br>Program stopped."
    of_waypoint_parameter_error_target="Parameter error.<br>Please define a valid Fixed, Variable or Relative F/T Waypoint."
    of_waypoint_parameter_error_close="Parameter error.<br>The given pose is too close to the last one. Program stopped."
    of_waypoint_parameter_error_distance="Distance to the last pose: "
  
  
    #======    End of OnRobot F/T Waypoint Messages    ======#
  
    #======    OnRobot F/T Waypoint    ======#
  
    def of_waypoint_send(wp):
    if not(wp==ZEROPOSE):
    relativeWPInt=0
    of_send_full(OF_CMD_WAYPOINT,of_float_to_int(wp[0]),of_float_to_int(wp[1]),of_float_to_int(wp[2]),of_float_to_int(wp[3]),of_float_to_int(wp[4]),of_float_to_int(wp[5]),relativeWPInt)
    if OF_DEBUG_STATE:
    textmsg("FT Waypoint sent: ",wp)
    end
    of_move_wp_count=of_move_wp_count+1
    else:
    textmsg("Invalid FT Waypoint and not sent")
    end
    end
    def of_waypoint(fixP=ZEROPOSE,variableP=p[0,0,0,0,0,0],relativeP=p[0,0,0,0,0,0]):
    sync()
    local mergedWP=ZEROPOSE
    local startPose=ZEROPOSE
    local frameID=of_move_frameID
    if not(of_move_state==OF_MOVE_STATE_INITED):
    textmsg("of_move_state: ",of_move_state)
    popup(of_waypoint_move_state_error,title=of_waypoint_error_title,error=True,blocking=False)
    halt
    end
    if of_move_path_count!=0:
    popup(of_waypoint_path_count_error,title=of_waypoint_error_title,error=True,blocking=False)
    halt
    end
    if fixP==ZEROPOSE:
    if variableP==ZEROPOSE:
    if(relativeP==ZEROPOSE):
    popup(of_waypoint_parameter_error_target,title=of_waypoint_error_title,error=True,blocking=False)
    halt
    end
    if frameID==0:
    startPose=of_move_last_pose
    elif frameID==1:
    startPose=ZEROPOSE
    elif frameID==2:
    startPose=pose_trans(pose_inv(of_move_frame),of_move_last_pose)
    elif frameID==3:
    startPose=pose_inv(of_move_frame)
    else:
    startPose=of_move_last_pose
    end
    else:
    startPose=variableP
    end
    mergedCustom=pose_add(relativeP,startPose)
    if frameID==0:
    mergedWP=mergedCustom
    elif frameID==1:
    mergedWP= pose_trans(of_move_last_pose,mergedCustom)
    elif frameID==2:
    mergedWP=pose_trans(of_move_frame,mergedCustom)
    elif frameID==3:
    local customMerged=pose_trans(of_move_frame,mergedCustom)
    mergedWP=pose_trans(of_move_last_pose,customMerged)
    end
    else:
    mergedWP=fixP
    end
    local poseDiff=point_dist(mergedWP,of_move_last_pose)
    if((of_move_wp_count!=0)and(poseDiff<of_move_min_dist)):
    textmsg(of_waypoint_parameter_error_distance,poseDiff)
    popup(of_waypoint_parameter_error_close,title=of_waypoint_error_title,error=True,blocking=False)
    halt
    else:
    of_waypoint_send(mergedWP)
    end
    of_move_last_pose=mergedWP
    return mergedWP
    end
  
  
    #======    End of OnRobot F/T Waypoint    ======#
  
    #======    OnRobot F/T Path Messages    ======#
  
    of_path_error_title="OnRobot - F/T Path error"
    of_path_move_state_error="Wrong program structure when initializing F/T Path.<br>Program stopped.<br>Make sure that the F/T Path is under F/T Move or F/T Search in a right structure."
    of_path_path_count_error=" Incorrect use of F/T Path.<br>Do not use multiple F/T Paths in the same F/T Move or F/T Search.<br>Program stopped."
    of_path_wp_count_error=" Incorrect use of F/T Path.<br>Do not use F/T Waypoint and F/T Path in the same F/T Move or F/T Search.<br>Program stopped."
    of_path_parameter_error_pathid="Parameter error.<br>Invalid F/T Path ID."
  
  
    #======    End of OnRobot F/T Path Messages    ======#
  
    #======    OnRobot F/T Path    ======#
  
    def of_path(pathID):
    sync()
    if not(of_move_state==OF_MOVE_STATE_INITED or of_move_state==OF_MOVE_STATE_PATH_STOPPED):
    textmsg("of_move_state: ",of_move_state)
    popup(of_path_move_state_error,title=of_path_error_title,error=True,blocking=False)
    halt
    end
    if not(of_move_path_count==0):
    popup(of_path_path_count_error,title=of_path_error_title,error=True,blocking=False)
    halt
    end
    if not((of_move_wp_count==0 and not of_move_path_move_home)or(of_move_wp_count==1 or of_move_path_move_home)):
    textmsg("Path home & Waypoint#: ",[binary_list_to_integer([of_move_path_move_home]),of_move_wp_count])
    popup(of_path_wp_count_error,title=of_path_error_title,error=True,blocking=False)
    halt
    end
    if not(pathID>0 or pathID==-1):
    popup(of_path_parameter_error_pathid,title=of_path_error_title,error=True,blocking=False)
    halt
    end
    of_move_path_move_home=False
    of_send_full(OF_CMD_PATH,pathID)
    of_move_path_count=of_move_path_count+1
    if OF_DEBUG_STATE:
    textmsg("FT Path sent: ",pathID)
    end
    end
    def of_path_play(pathID=0,relative=False,homePose=ZEROPOSE):
    if relative:
    of_move_path_move_home=False
    else:
    of_move_path_move_home=True
    end
    if not relative:
    of_waypoint(fixP=homePose)
    of_move_start_move(popupmsg=False)
    end
    of_path(pathID)
    end
  
  
    #======    End of OnRobot F/T Path    ======#
  
    #======    OnRobot DIO    ======#
  
    def of_digital_out_send(port,value):
    of_send_full(OF_CMD_DIO,port,value)
    return 0
    end
    def of_digital_out_set_polling():
    local digital_in_return=of_wait_for_return(OF_CMD_DIO,blocking=True)
    local receivedList=integer_to_binary_list(digital_in_return)
    local valueDO=receivedList[31]
    receivedList[31]=False
    local receivedDO=binary_list_to_integer(receivedList)
    if OF_DEBUG_RX:
    textmsg("Return Set DO command received: ",[receivedDO,valueDO])
    end
    set_standard_digital_out(receivedDO,valueDO)
    if OF_DEBUG_STATE:
    textmsg("Digital Output #, set to #: ",[receivedDO,valueDO])
    end
    end
  
  
    #======    End of OnRobot DIO    ======#
  
    #======    OnRobot AIO    ======#
  
    def of_analog_out_send(port,value):
    of_send_full(OF_CMD_DIO,port,of_float_to_int(value))
    return 0
    end
    def of_analog_out_set_polling():
    local receivedInt=of_wait_for_return(OF_CMD_AIO,bloking=True)
    local selector=pow(2,16)
    local receivedAO=receivedInt%selector
    local valueAO=(receivedInt-receivedAO)/selector/selector
    if OF_DEBUG_RX:
    textmsg("Return Set AO command received: ",[receivedAO,valueAO])
    end
    if receivedAO==0 or receivedAO==1:
    set_standard_analog_out(receivedAO,valueAO)
    else:
    textmsg("Invalid Analog Output selected! ",receivedAO)
    end
    of_send_full(OF_CMD_ACK)
    if OF_DEBUG_STATE:
    textmsg("Analog Output #, set to #: ",[receivedAO,valueAO])
    end
    end
  
  
    #======    End of OnRobot AIO    ======#
  
    #======    OnRobot F/T Insert Pin Messages    ======#
  
    of_insert_pin_error_title="OnRobot - Insert Pin error"
    of_insert_pin_state_error_start="Wrong F/T Insert Pin status when initializing.<br>Another thread is using an F/T Insert Pin command. Program stopped."
    of_insert_pin_state_error_return="Wrong F/T Insert Pin status when returning.<br>Another thread is using an F/T Insert Pin command. Program stopped."
    of_insert_pin_return_title="OnRobot - Insert Pin"
    of_insert_pin_return_0="The insertion has reached the maximal insertion depth."
    of_insert_pin_return_1="The insertion bumped after the minimal insertion depth."
    of_insert_pin_return_2="The insertion slowed down after the minimal insertion depth."
    of_insert_pin_return_3="The insertion got stuck before the minimal insertion depth."
    of_insert_pin_return_4="The command has timed out after the minimal insertion depth."
    of_insert_pin_return_5="The command has timed out before the minimal insertion depth."
    of_insert_pin_return_6="The side-force/-torque limit has been reached after the minimal insertion depth."
    of_insert_pin_return_7="The side-force/-torque limit has been reached before the minimal insertion depth."
    of_insert_pin_return_8="Parameter error returned from the Compute Box.<br>Check the parameters for the F/T Insert Pin command."
    of_insert_pin_return_unknown="F/T Insert Pin finished with unknown return value."
  
  
    #======    End of OnRobot F/T Insert Pin Messages    ======#
  
    #======    OnRobot F/T Insert Pin    ======#
  
    of_insert_pin_state=0
    of_insert_pin_return=0
    of_insert_pin_frameID=1
    of_insert_pin_frameID_default=1
    of_insert_pin_frameRPY=[0,0,0]
    of_insert_pin_frameRPY_default=[0,0,0]
    of_insert_pin_retAccept=[True,True,True,False,False,False,False,False,False]
    of_insert_pin_retAccept_default=[True,True,True,False,False,False,False,False,False]
    OF_INSERT_PIN_STATE_IDLE=0
    OF_INSERT_PIN_STATE_INIT=1
    OF_INSERT_PIN_STATE_STARTED=2
    OF_INSERT_PIN_STATE_RETURNING=3
    of__insert_pin_param_error_minDistZ="Please define parameter 'minDistZ' as a positive real number in meters!"
    of__insert_pin_param_error_forceZ="Please define parameter 'forceZ' as a positive number in Newtons!"
    of__insert_pin_param_error_maxDistZ="Please define parameter 'maxDistZ' as a positive real number in meters!"
    of__insert_pin_param_error_maxDistZ_minDistZ="Please define the parameters as 'maxDistZ' >= 'minDistZ'!"
    of__insert_pin_param_error_expSpeed="Please define parameter 'expSpeed' as a positive real number in meters!"
    of__insert_pin_param_error_deltaForce="Please define parameter 'deltaForce' as a positive number in Newtons!"
    of__insert_pin_param_error_timeOut="Please define parameter 'timeOut' as a positive number in seconds!"
    of__insert_pin_param_error_FTLimits="Please define parameter 'FTLimits' as a 6-element array of positive numbers in Newtons & Newton-meters!"
    of__insert_pin_param_error_PGainFxy="Please define parameter 'PGainFxy' as a positive real number!"
    of__insert_pin_param_error_PGainFz="Please define parameter 'PGainFz' as a positive real number!"
    of__insert_pin_param_error_PGainTxy="Please define parameter 'PGainTxy' as a positive real number!"
    of__insert_pin_param_error_PGainTz="Please define parameter 'PGainTz' as a positive real number!"
    def of_insert_pin(forceZ,minDistZ,maxDistZ=0,deltaForce=0,expSpeed=0,timeOut=0,compliance=[True,True,True,True,True,True],FTLimits=[0,0,0,0,0,0],PGainFxy=1.0,PGainFz=1.0,PGainTxy=0.2,PGainTz=0.2,popupmsg=True):
    sync()
    if OF_DEBUG_STATE:
    textmsg("Insert Pin starting..")
    end
    if not(of_insert_pin_state==OF_INSERT_PIN_STATE_IDLE):
    textmsg("of_insert_pin_state: ",of_insert_pin_state)
    popup(of_insert_pin_state_error_start,title=of_insert_pin_error_title,error=True,blocking=False)
    halt
    else:
    enter_critical
    of_insert_pin_state=OF_INSERT_PIN_STATE_INIT
    exit_critical
    end
    of_insert_pin_return=0
    if not(minDistZ>=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_minDistZ,title=of_insert_pin_error_title,error=True,blocking=True)
    elif not(forceZ!=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_forceZ,title=of_insert_pin_error_title,error=True,blocking=True)
    elif not(maxDistZ>=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_maxDistZ,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(maxDistZ>=minDistZ or maxDistZ==0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_maxDistZ_minDistZ,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(expSpeed>=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_expSpeed,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(deltaForce>=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_deltaForce,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(timeOut>=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_timeOut,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(FTLimits[0]>=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_FTLimits,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(FTLimits[1]>=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_FTLimits,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(FTLimits[3]>=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_FTLimits,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(FTLimits[4]>=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_FTLimits,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(FTLimits[5]>=0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_FTLimits,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(PGainFxy>0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_PGainFxy,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(PGainFz>0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_PGainFz,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(PGainTxy>0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_PGainTxy,title=of_insert_pin_error_title,error=True,blocking=False)
    elif not(PGainTz>0):
    of_insert_pin_return=8
    popup(of__insert_pin_param_error_PGainTz,title=of_insert_pin_error_title,error=True,blocking=False)
    end
    if(of_insert_pin_return!=0):
    halt
    end
    of_tcp_offset_send_actual()
    local retAccept=of_insert_pin_retAccept
    of_insert_pin_retAccept=of_insert_pin_retAccept_default
    local ft_compliance=compliance
    ft_compliance[2]=True
    local ft_threshold=[FTLimits[0],FTLimits[1],(forceZ+deltaForce),FTLimits[3],FTLimits[4],FTLimits[5],0,0]
    i=0
    while i<6:
    if ft_compliance[i]:
    ft_threshold[i]=0
    end
    i=i+1
    end
    local flags=binary_list_to_integer(ft_compliance)+(of_insert_pin_frameID*64)
    of_insert_pin_frameID=of_insert_pin_frameID_default
    local of_insert_pin_frame=rpy2rotvec(of_insert_pin_frameRPY)
    of_insert_pin_frameRPY=of_insert_pin_frameRPY_default
    sync()
    of_send_full(OF_CMD_INSERT_PIN,of_float_to_int(forceZ),of_float_to_int(minDistZ),of_float_to_int(maxDistZ),of_float_to_int(deltaForce),of_float_to_int(expSpeed),of_float_to_int(timeOut),flags,of_float_to_int(ft_threshold[0]),of_float_to_int(ft_threshold[1]),of_float_to_int(ft_threshold[3]),of_float_to_int(ft_threshold[4]),of_float_to_int(ft_threshold[5]),of_float_to_int(PGainFxy),of_float_to_int(PGainFz),of_float_to_int(PGainTxy),of_float_to_int(PGainTz))
    of_speedl_start_for_CMD(OF_CMD_INSERT_PIN)
    if OF_DEBUG_STATE:
    textmsg("Insert Pin command sent, waiting for the return.")
    end
    enter_critical
    of_insert_pin_state=OF_INSERT_PIN_STATE_STARTED
    exit_critical
    of_insert_pin_return=of_wait_for_return(OF_CMD_INSERT_PIN,blocking=True)
    of_speedl_stop_for_CMD(OF_CMD_INSERT_PIN)
    if OF_DEBUG_STATE:
    textmsg("Insert Pin returned.")
    end
    if of_insert_pin_return==0:
    if(popupmsg and(not retAccept[0])):
    popup(of_insert_pin_return_0,title=of_insert_pin_return_title,warning=True,blocking=True)
    end
    elif of_insert_pin_return==1:
    if(popupmsg and(not retAccept[1])):
    popup(of_insert_pin_return_1,title=of_insert_pin_return_title,warning=True,blocking=True)
    end
    elif of_insert_pin_return==2:
    if(popupmsg and(not retAccept[2])):
    popup(of_insert_pin_return_2,title=of_insert_pin_return_title,warning=True,blocking=True)
    end
    elif of_insert_pin_return==3:
    if(popupmsg and(not retAccept[3])):
    popup(of_insert_pin_return_3,title=of_insert_pin_return_title,warning=True,blocking=True)
    end
    elif of_insert_pin_return==4:
    if(popupmsg and(not retAccept[4])):
    popup(of_insert_pin_return_4,title=of_insert_pin_return_title,warning=True,blocking=True)
    end
    elif of_insert_pin_return==5:
    if(popupmsg and(not retAccept[5])):
    popup(of_insert_pin_return_5,title=of_insert_pin_return_title,warning=True,blocking=True)
    end
    elif of_insert_pin_return==6:
    if(popupmsg and(not retAccept[6])):
    popup(of_insert_pin_return_6,title=of_insert_pin_return_title,warning=True,blocking=True)
    end
    elif of_insert_pin_return==7:
    if(popupmsg and(not retAccept[7])):
    popup(of_insert_pin_return_7,title=of_insert_pin_return_title,warning=True,blocking=True)
    end
    else:
    popup(of_insert_pin_return_unknown,title=of_insert_pin_return_title,warning=True,blocking=True)
    end
    enter_critical
    of_insert_pin_state=OF_INSERT_PIN_STATE_IDLE
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("End of Insert Pin.")
    end
    return of_insert_pin_return
    end
  
  
    #======    End of OnRobot F/T Insert Pin    ======#
  
    #======    OnRobot Applications Messages    ======#
  
    of_pin_insertion_exit_title="OnRobot - Insert Pin"
    of_pin_insertion_exit_maxSideFT="The side-force/-torque limit has been reached after the minimal insertion depth."
    of_pin_insertion_exit_maxSideFT="The side-force/-torque limit has been reached after the minimal insertion depth."
    of_pin_insertion_exit_timeOut="The command has timed out after the minimal insertion depth."
    of_pin_insertion_exit_timeOut="The command has timed out after the minimal insertion depth."
    of_pin_insertion_exit_deltaD="The insertion got stuck before the minimal insertion depth."
    of_center_title="OnRobot - FT Center"
    of_center_return_1="The first boundary search was unsuccessful. Movement reached the distance limit."
    of_center_return_2="The second boundary search was unsuccessful. Movement reached the distance limit."
    of_center_return_3="Could not reach the center point. The tool collided during the movement."
    of_center_return_4="The search has not been started because of the conditions."
    of_center_return_5="The second search has not been started because of the conditions."
    of_center_return_99="Do not define more than one directional parameter."
    of_center_rxry_title="OnRobot - Orientation center"
    of_center_rxry_return_1="The Orientation centerpoint search of Rx was unsuccessful!"
    of_center_rxry_return_2="The Orientation centerpoint search of Ry was unsuccessful!"
    of_fix_and_rotate_title="OnRobot - FT Fix & Rotate"
    of_fix_and_rotate_return_21="The rotation was unsuccessful, collision occurred."
    of_fix_and_rotate_return_22="The rotation ended without contact."
    of_box_ins_title="OnRobot - FT Insert Box"
    of_box_ins_return_1="The first direction search was unsuccessful. Movement reached the distance limit."
    of_box_ins_return_2="The second direction search was unsuccessful. Movement reached the distance limit."
    of_box_ins_return_3="The tilt back movement was unsuccessful. Collision occurred."
    of_box_ins_return_4="The tilt movement was unsuccessful. Collision occurred."
    of_box_ins_return_5="The box stuck during the insertion state while center pointing of the X axis! Please check the position and orientation."
    of_box_ins_return_6="The box stuck during the insertion state while center pointing of the Y axis! Please check the position and orientation."
    of_box_ins_return_7="The box stuck during the insertion state while center pointing of the Z axis! Please check the position and orientation."
    of_box_ins_return_8="The box cannot be inserted to position, too many collisions occurred. Please check the position and orientation."
    of_stacking_title="OnRobot - FT Stack/Destack"
    of_stacking_return_1_stack="The iteration counter is over the maximum: the stack is full."
    of_stacking_return_1_destack="The iteration counter is over the maximum: the stack is empty."
    of_stacking_return_2="Stacking/Destacking is unsuccessful. Next item not found."
    of_stacking_return_3="Stacking/Destacking cannot start due to a force or torque exceeding the set limit."
    of_stacking_return_4="The movement to the next element was unsuccessful, a collision occurred."
    of_stacking_return_5="The movement to the starting point was unsuccessful, a collision occurred."
    of_guard_title="OnRobot - F/T Guard"
    of_guard_reached="The F/T Guard set limit has been reached. Program halted."
    of_elements_onrobot="OnRobot"
    of_ur_move_return_title="OnRobot - F/T Move (UR)"
    of_ur_search_return_title="OnRobot - F/T Search (UR)"
    of_merge_poses_invalid="Please define a valid target pose or relative movement!"
    of_merge_poses_both="Please define only one valid target pose or relative movement!"
  
  
    #======    End of OnRobot Applications Messages    ======#
  
    #======    OnRobot Elements    ======#
  
    sync()
    MATH_PI=3.141593
    bFT=[0,0,0,0,0,0]
    tFT=[0,0,0,0,0,0]
    def of_qu_inv(qu):
    return[qu[0],-qu[1],-qu[2],-qu[3]]
    end
    def of_qu_mult(x,y):
    local qa=x[0]*y[0]-x[1]*y[1]-x[2]*y[2]-x[3]*y[3]
    local qb=x[0]*y[1]+x[1]*y[0]+x[2]*y[3]-x[3]*y[2]
    local qc=x[0]*y[2]-x[1]*y[3]+x[2]*y[0]+x[3]*y[1]
    local qd=x[0]*y[3]+x[1]*y[2]-x[2]*y[1]+x[3]*y[0]
    local retVal=[qa,qb,qc,qd]
    return retVal
    end
    def of_rotvec2qu(rv):
    local rvlen=sqrt(rv[0]*rv[0]+rv[1]*rv[1]+rv[2]*rv[2])
    if rvlen!=0:
    local rv4=[rvlen,rv[0]/rvlen,rv[1]/rvlen,rv[2]/rvlen]
    else:
    local rv4=[0,0,0,0]
    end
    local rvs=sin(rv4[0]/2)
    return[cos(rv4[0]/2),rvs*rv4[1],rvs*rv4[2],rvs*rv4[3]]
    end
    def of_rotate_qu(v,q):
    local v4=[0,v[0],v[1],v[2]]
    local r4a=of_qu_mult(q,v4)
    local r4b=of_qu_inv(q)
    local r4=of_qu_mult(r4a,r4b)
    return[r4[1],r4[2],r4[3]]
    end
    def of_pose_add(tt,ss,base=True):
    if base:
    local rr=pose_add(ss,tt)
    else:
    local rr=pose_trans(tt,ss)
    end
    return rr
    end
    def of_threshold(fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,f3d=0,t3d=0,force_abs=True,base=True):
    local is_above_the_threshold=False
    def check_limit(force,limit,fabs):
    if limit!=0:
    if(fabs)and norm(force)>=norm(limit):
    return True
    elif(not fabs)and((limit<0 and force<=limit)or(limit>0 and force>=limit)):
    return True
    else:
    return False
    end
    else:
    return False
    end
    end
    if base:
    local compareFT=bFT
    else:
    local compareFT=tFT
    end
    if(check_limit(compareFT[0],fx,force_abs)):
    is_above_the_threshold=True
    end
    if(check_limit(compareFT[1],fy,force_abs)):
    is_above_the_threshold=True
    end
    if(check_limit(compareFT[2],fz,force_abs)):
    is_above_the_threshold=True
    end
    if(check_limit(compareFT[3],tx,force_abs)):
    is_above_the_threshold=True
    end
    if(check_limit(compareFT[4],ty,force_abs)):
    is_above_the_threshold=True
    end
    if(check_limit(compareFT[5],tz,force_abs)):
    is_above_the_threshold=True
    end
    if f3d!=0 and norm(F3D)>=norm(f3d):
    is_above_the_threshold=True
    end
    if t3d!=0 and norm(T3D)>=norm(t3d):
    is_above_the_threshold=True
    end
    return is_above_the_threshold
    end
    def of_above_zero(fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,zeroVal=0,base=True):
    local is_above_the_threshold=False
    def check_zero(force,axis,limit):
    if axis!=0:
    if(force>limit):
    return True
    else:
    return False
    end
    else:
    return False
    end
    end
    if base:
    local compareFT=bFT
    else:
    local compareFT=tFT
    end
    if(check_zero(compareFT[0],fx,zeroVal)):
    is_above_the_threshold=True
    end
    if(check_zero(compareFT[1],fy,zeroVal)):
    is_above_the_threshold=True
    end
    if(check_zero(compareFT[2],fz,zeroVal)):
    is_above_the_threshold=True
    end
    if(check_zero(compareFT[3],tx,zeroVal)):
    is_above_the_threshold=True
    end
    if(check_zero(compareFT[4],ty,zeroVal)):
    is_above_the_threshold=True
    end
    if(check_zero(compareFT[5],tz,zeroVal)):
    is_above_the_threshold=True
    end
    return is_above_the_threshold
    end
    of_go_new_pos=p[0,0,0,0,0,0]
    of_go_acc=0
    of_go_speed=0
    of_go_thread_flag=-1
    of_joint_move=False
    of_go_time=0
    of_go_blend=0
    of_joint_move=False
    of_go_thread_handler=0
    thread of_go_thread():
    if of_joint_move:
    movej(of_go_new_pos,a=of_go_acc,v=of_go_speed)
    else:
    movel(of_go_new_pos,a=of_go_acc,v=of_go_speed)
    end
    of_go_thread_flag= 1
    end
    def of_go(of_go_target,fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,f3d=0,t3d=0,speed=0.03,acc=1.2,brake=1.2,force_abs=True,base=True,joint_move=False):
    sync()
    of_go_new_pos=of_go_target
    of_go_acc=acc
    of_go_speed=speed
    of_joint_move=joint_move
    of_go_thread_flag=0
    sync()
    if of_threshold(fx,fy,fz,tx,ty,tz,f3d,t3d,force_abs,base)==False:
    of_go_thread_flag=0
    of_go_thread_handler=run of_go_thread()
    sync()
    while(of_go_thread_flag==0):
    if of_threshold(fx,fy,fz,tx,ty,tz,f3d,t3d,force_abs,base)==False:
    sync()
    else:
    kill of_go_thread_handler
    if of_joint_move:
    stopj(brake)
    else:
    stopl(brake)
    end
    of_go_thread_flag=2
    end
    end
    end
    return of_go_thread_flag
    end
    def of_merge_poses(target,x,y,z,rx,ry,rz,base=True):
    if target==p[0,0,0,0,0,0]:
    if(x!=0 or y!=0 or z!=0 or rx!=0 or ry!=0 or rz!=0):
    local actpos=get_actual_tcp_pose()
    sync()
    local merged=of_pose_add(actpos,p[x,y,z,-rx,-ry,-rz],base)
    sync()
    return merged
    else:
    popup(of_merge_poses_invalid,title=of_elements_onrobot,error=True,blocking=False)
    halt
    end
    else:
    if(x==0 and y==0 and z==0 and rx==0 and ry==0 and rz==0):
    return target
    else:
    popup(of_merge_poses_both,title=of_elements_onrobot,error=True,blocking=False)
    halt
    end
    end
    end
    of_ftpid_p_pith=0.2
    of_ftpid_i_pith=0.0
    of_ftpid_d_pith=0.0
    of_ftpid_p_pith_default=0.2
    of_ftpid_i_pith_default=0.0
    of_ftpid_d_pith_default=0.0
    of_fpid_i_pin=0.0
    of_fpid_d_pin=0.0
    of_fpid_i_pin_default=0.0
    of_fpid_d_pin_default=0.0
    of_tpid_i_pin=0.0
    of_tpid_d_pin=0.0
    of_tpid_i_pin_default=0.0
    of_tpid_d_pin_default=0.0
    of_ftpid_i_conn=0.0
    of_ftpid_d_conn=0.0
    of_tpid_div_conn=5
    of_ftpid_i_conn_default=0.0
    of_ftpid_d_conn_default=0.0
    of_tpid_div_conn_default=5
    def of_center_RxRy(AngR,TorqueXY,spdR,stateCntr=0,silent=False,base=True):
    sync()
    local state=0+stateCntr
    local retCVal=of_center(rx=AngR,t3d=TorqueXY,speed=spdR,acc=0.05,silent=True,base=base)
    if(retCVal==0):
    sync()
    elif(retCVal==1):
    state=1+stateCntr
    local retMVal=of_move_ur(rx=-AngR,tx=TorqueXY,speed=spdR,acc=0.05,silent=True,force_abs=False,base=base)
    if not silent:
    popup(of_center_rxry_return_1,title=of_fix_and_rotate_title,warning=True,blocking=True)
    end
    return 1
    elif(retCVal==2):
    state=2+stateCntr
    local retMVal=of_move_ur(rx=AngR,tx=-TorqueXY,speed=spdR,acc=0.05,silent=True,force_abs=False,base=base)
    if not silent:
    popup(of_center_rxry_return_1,title=of_fix_and_rotate_title,warning=True,blocking=True)
    end
    return 1
    else:
    state=3+stateCntr
    if not silent:
    popup(of_center_rxry_return_1,title=of_fix_and_rotate_title,warning=True,blocking=True)
    end
    return 1
    end
    state=3+stateCntr
    retCVal=of_center(ry=AngR,t3d=TorqueXY,speed=spdR,acc=0.05,silent=True,base=base)
    if(retCVal==0):
    sync()
    elif(retCVal==1):
    state=4+stateCntr
    sync()
    local retMVal=of_move_ur(ry=-AngR,ty=TorqueXY,speed=spdR,acc=0.05,silent=True,force_abs=False,base=base)
    if not silent:
    popup(of_center_rxry_return_2,title=of_fix_and_rotate_title,warning=True,blocking=True)
    end
    return 2
    elif(retCVal==2):
    state=5+stateCntr
    local retMVal=of_move_ur(ry=AngR,ty=-TorqueXY,speed=spdR,acc=0.05,silent=True,force_abs=False,base=base)
    if not silent:
    popup(of_center_rxry_return_2,title=of_fix_and_rotate_title,warning=True,blocking=True)
    end
    return 2
    else:
    state=3+stateCntr
    if not silent:
    popup(of_center_rxry_return_2,title=of_fix_and_rotate_title,warning=True,blocking=True)
    end
    return 2
    end
    return 0
    end
    of_peakFzScanner_flag=False
    min_bFT=[0,0,0,0,0,0]
    min0_bFT=[False,False,False,False,False,False]
    max_bFT=[0,0,0,0,0,0]
    max0_bFT=[False,False,False,False,False,False]
    abs_bFT=[0,0,0,0,0,0]
    abs0_bFT=[False,False,False,False,False,False]
    min_tFT=[0,0,0,0,0,0]
    min0_tFT=[False,False,False,False,False,False]
    max_tFT=[0,0,0,0,0,0]
    max0_tFT=[False,False,False,False,False,False]
    abs_tFT=[0,0,0,0,0,0]
    abs0_tFT=[False,False,False,False,False,False]
    min_3DFT=[0,0]
    min0_3DFT=[False,False]
    max_3DFT=[0,0]
    max0_3DFT=[False,False]
    thread of_peakFzScanner():
    of_peakFzScanner_flag=True
    abs_tFT[2]=0
    while(of_peakFzScanner_flag==True):
    i=0
    norm_tFT2=norm(tFT[2])
    if abs0_tFT[2]:
    abs_tFT[2]=0
    abs0_tFT[2]=False
    elif(abs_tFT[2]<norm_tFT2):
    abs_tFT[2]=norm_tFT2
    end
    sync()
    end
    return False
    end
    of_bi_cp_x_inv=False
    of_bi_cp_y_inv=False
    of_bi_cp_z_inv=False
    of_stack_curr_it=0
  
  
    #======    End of OnRobot Elements    ======#
  
    #======    OnRobot Applications    ======#
  
    def of_move_ur(target=p[0,0,0,0,0,0],x=0,y=0,z=0,rx=0,ry=0,rz=0,fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,f3d=0,t3d=0,speed=0.05,acc=1.2,brake=1.2,silent=False,force_abs=True,base=True,joint_move=False):
    sync()
    target=of_merge_poses(target,x,y,z,rx,ry,rz,base)
    sync()
    local ret=of_go(target,fx,fy,fz,tx,ty,tz,f3d,t3d,speed,acc,brake,force_abs,base,joint_move)
    if not silent:
    if ret==0:
    popup(of_move_move_return_2,title=of_ur_move_return_title,warning=True,blocking=True)
    elif ret==2:
    popup(of_move_move_return_1,title=of_ur_move_return_title,warning=True,blocking=True)
    end
    end
    return ret
    end
    def of_search_ur(target=p[0,0,0,0,0,0],x=0,y=0,z=0,rx=0,ry=0,rz=0,fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,f3d=0,t3d=0,speed=0.03,acc=1.2,brake=1.2,silent=False,force_abs=True,base=True):
    sync()
    target=of_merge_poses(target,x,y,z,rx,ry,rz,base)
    sync()
    local ret=of_go(target,fx,fy,fz,tx,ty,tz,f3d,t3d,speed,acc,brake,force_abs,base)
    if not silent:
    if ret==0:
    popup(of_move_search_return_2,title=of_ur_search_return_title,warning=True,blocking=True)
    elif ret==1:
    popup(of_move_search_return_1,title=of_ur_search_return_title,warning=True,blocking=True)
    end
    end
    return ret
    end
    def of_center(x=0,y=0,z=0,rx=0,ry=0,rz=0,fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,f3d=0,t3d=0,speed=0.03,speedCP=99999,acc=0.2,brake=1.2,silent=False,force_abs=True,base=True):
    sync()
    if speedCP==99999:
    speedCP=speed
    end
    def invert_offset(o):
    local i=0
    local r=p[0,0,0,0,0,0]
    while(i<6):
    if(o[i]!=0):
    r[i]=-o[i]
    else:
    r[i]=0
    end
    i=i+1
    end
    return r
    end
    local search3D=False
    local db=0
    if x!=0:
    db=db+1
    end
    if y!=0:
    db=db+1
    end
    if z!=0:
    db=db+1
    end
    if rx!=0:
    db=db+1
    end
    if ry!=0:
    db=db+1
    end
    if rz!=0:
    db=db+1
    end
    if db==0:
    popup(of_center_return_99,title=of_center_title,error=True,blocking=True)
    return 99
    end
    if db>1:
    popup(of_center_return_99,title=of_center_title,error=True,blocking=True)
    return 99
    end
    sync()
    if f3d!=0:
    force_abs=True
    search3D=True
    if(fx==0 and fy==0 and fz==0):
    fx=f3d*0.57735
    fy=fx
    fz=fx
    end
    f3d=norm(f3d)
    end
    if t3d!=0:
    force_abs=True
    search3D=True
    if(tx==0 and ty==0 and tz==0):
    tx=t3d*0.57735
    ty=tx
    tz=tx
    end
    t3d=norm(t3d)
    end
    local offset=p[x,y,z,-rx,-ry,-rz]
    if(force_abs):
    fx=norm(fx)
    fy=norm(fy)
    fz=norm(fz)
    tx=norm(tx)
    ty=norm(ty)
    tz=norm(tz)
    else:
    local reverse=of_threshold(fx,fy,fz,tx,ty,tz,force_abs=False,base=base)
    if reverse:
    offset=invert_offset(offset)
    fx=-fx
    fy=-fy
    fz=-fz
    tx=-tx
    ty=-ty
    tz=-tz
    end
    end
    sync()
    local start_wp=get_actual_tcp_pose()
    local target=of_pose_add(start_wp,offset,base)
    of_wait_ms(200)
    sync()
    local ret=of_search_ur(target=target,fx=fx,fy=fy,fz=fz,tx=tx,ty=ty,tz=tz,f3d=f3d,t3d=t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=force_abs,base=base)
    if ret!=1:
    sync()
    if(ret==0 and force_abs==True):
    if not silent:
    popup(of_center_return_4,title=of_center_title,warning=True,blocking=True)
    end
    return 4
    end
    local pose1=get_actual_tcp_pose()
    of_wait_ms(200)
    sync()
    if(force_abs):
    local mret=0
    if(search3D):
    mret=of_search_ur(target=start_wp,f3d=3*f3d,t3d=3*t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=True,base=base)
    else:
    local aboveZ=of_above_zero(fx,fy,fz,tx,ty,tz,0,base)
    sync()
    if(aboveZ):
    mret=of_search_ur(target=start_wp,fx=-fx,fy=-fy,fz=-fz,tx=-tx,ty=-ty,tz=-tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    else:
    mret=of_search_ur(target=start_wp,fx=fx,fy=fy,fz=fz,tx=tx,ty=ty,tz=tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    end
    end
    sync()
    if mret!=1:
    if mret==0:
    if not silent:
    popup(of_center_return_5,title=of_center_title,warning=True,blocking=True)
    end
    return 5
    end
    sync()
    local pose2=get_actual_tcp_pose()
    local poseC=interpolate_pose(pose1,pose2,0.5)
    sync()
    if(search3D):
    mret=of_move_ur(poseC,f3d=6*f3d,t3d=6*t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=True,base=base)
    else:
    local aboveZ=of_above_zero(fx,fy,fz,tx,ty,tz,0,base)
    if(aboveZ):
    mret=of_move_ur(poseC,fx=3*fx,fy=3*fy,fz=3*fz,tx=3*tx,ty=3*ty,tz=3*tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    else:
    mret=of_move_ur(poseC,fx=-3*fx,fy=-3*fy,fz=-3*fz,tx=-3*tx,ty=-3*ty,tz=-3*tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    end
    end
    if mret==1:
    return 0
    else:
    if not silent:
    popup(of_center_return_3,title=of_center_title,warning=True,blocking=True)
    end
    return 3
    end
    end
    end
    sync()
    local offset2=invert_offset(offset)
    sync()
    target=of_pose_add(start_wp,offset2,base)
    sync()
    local ret2=of_search_ur(target,fx=-fx,fy=-fy,fz=-fz,tx=-tx,ty=-ty,tz=-tz,f3d=f3d,t3d=t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=force_abs,base=base)
    if ret2!=1:
    sync()
    local pose2=get_actual_tcp_pose()
    local poseC=interpolate_pose(pose1,pose2,0.5)
    local mret=0
    of_wait_ms(200)
    sync()
    if(force_abs):
    if(search3D):
    mret=of_move_ur(poseC,f3d=3*f3d,t3d=3*t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    else:
    local aboveZ=of_above_zero(fx,fy,fz,tx,ty,tz,0,base)
    if(aboveZ):
    mret=of_move_ur(poseC,fx=-fx,fy=-fy,fz=-fz,tx=-tx,ty=-ty,tz=-tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    else:
    mret=of_move_ur(poseC,fx=fx,fy=fy,fz=fz,tx=tx,ty=ty,tz=tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    end
    end
    else:
    mret=of_move_ur(poseC,fx=fx,fy=fy,fz=fz,tx=tx,ty=ty,tz=tz,speed=speedCP,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    end
    sync()
    if mret==1:
    return 0
    else:
    if not silent:
    popup(of_center_return_3,title=of_center_title,warning=True,blocking=True)
    end
    return 3
    end
    else:
    if not silent:
    popup(of_center_return_2,title=of_center_title,warning=True,blocking=True)
    end
    return 2
    end
    else:
    if not silent:
    popup(of_center_return_1,title=of_center_title,warning=True,blocking=True)
    end
    return 1
    end
    end
    of__pin_insertion_param_error_title="OnRobot - Insert Pin error"
    of__pin_insertion_param_error_minDistZ="Please define parameter 'minDistZ' as a positive real number in meters!"
    of__pin_insertion_param_error_forceZ="Please define parameter 'forceZ' as a positive number in Newtons!"
    of__pin_insertion_param_error_maxDistZ="Please define parameter 'maxDistZ' as a positive real number in meters!"
    of__pin_insertion_param_error_maxDistZ_minDistZ="Please define the parameters as 'maxDistZ' >= 'minDistZ'!"
    of__pin_insertion_param_error_expSpeed="Please define parameter 'expSpeed' as a positive real number in meters!"
    of__pin_insertion_param_error_deltaForce="Please define parameter 'deltaForce' as a positive number in Newtons!"
    of__pin_insertion_param_error_timeOut="Please define parameter 'timeOut' as a positive number in seconds!"
    of__pin_insertion_param_error_FTLimits="Please define parameter 'FTLimits' as a 6-element array of positive numbers in Newtons & Newton-meters!"
    of__pin_insertion_param_error_PGainF="Please define parameter 'PGainF' as a positive real number!"
    of__pin_insertion_param_error_PGainT="Please define parameter 'PGainT' as a positive real number!"
    def of_pin_insertion(minDistZ,forceZ,compliance=[True,True,True,True,True,True],maxDistZ=0,expSpeed=0,deltaForce=1,timeOut=0,FTLimits=[999,999,0,999,999,999],PGainF=1.0,PGainT=1.0,silent=False):
    sync()
    local pinRet=0
    if not(minDistZ>=0):
    popup(of__pin_insertion_param_error_minDistZ,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(forceZ>0):
    popup(of__pin_insertion_param_error_forceZ,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(maxDistZ>=0):
    popup(of__pin_insertion_param_error_maxDistZ,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(maxDistZ>=minDistZ or maxDistZ==0):
    popup(of__pin_insertion_param_error_maxDistZ_minDistZ,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(expSpeed>=0):
    popup(of__pin_insertion_param_error_expSpeed,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(deltaForce>=0):
    popup(of__pin_insertion_param_error_deltaForce,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(timeOut>=0):
    popup(of__pin_insertion_param_error_timeOut,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(FTLimits[0]>=0):
    popup(of__pin_insertion_param_error_FTLimits,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(FTLimits[1]>=0):
    popup(of__pin_insertion_param_error_FTLimits,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(FTLimits[3]>=0):
    popup(of__pin_insertion_param_error_FTLimits,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(FTLimits[4]>=0):
    popup(of__pin_insertion_param_error_FTLimits,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(FTLimits[5]>=0):
    popup(of__pin_insertion_param_error_FTLimits,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(PGainF>0):
    popup(of__pin_insertion_param_error_PGainF,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    elif not(PGainT>0):
    popup(of__pin_insertion_param_error_PGainT,title=of__pin_insertion_param_error_title,error=True,blocking=False)
    pinRet=8
    end
    if(pinRet!=0):
    halt
    end
    of_tcp_offset_send_actual()
    local frameID=1
    local base=False
    local startPose=get_actual_tcp_pose()
    if maxDistZ==0:
    maxDistZ=minDistZ
    end
    local dist2Reach=maxDistZ
    sync()
    local ft_select=compliance
    ft_select[2]=True
    local ft_values=[0,0,0,0,0,0]
    ft_values[2]=forceZ
    local ft_threshold=FTLimits
    ft_threshold[2]=0
    i=0
    while i<6:
    if ft_select[i]:
    ft_threshold[i]=0
    end
    i=i+1
    end
    local pin_useTimeOut=True
    if timeOut==0:
    pin_useTimeOut=False
    end
    local timeOut100ms=timeOut*10
    local deltaD=expSpeed/10
    global of_pin_currentDist=0
    local peakScanner=run of_peakFzScanner()
    sync()
    local pin_forcePID=[PGainF,of_fpid_i_pin,of_fpid_d_pin]
    local pin_torquePID=[PGainT,of_tpid_i_pin,of_tpid_d_pin]
    of_ft_control_start(ft_select=ft_select,ft_values=ft_values,frameID=frameID,frameRPY=[0,0,0],forcePID=pin_forcePID,torquePID=pin_torquePID,deviation_max=0)
    local cntr=0
    local leaveInsertion=False
    local bumpZeroPeak=True
    local pin_actual_pose=get_actual_tcp_pose()
    of_pin_currentDist=point_dist(startPose,pin_actual_pose)
    local pin_last_pose=pin_actual_pose
    global actual_deltaD=deltaD
    while((of_pin_currentDist<dist2Reach)and not leaveInsertion):
    of_wait_ms(100)
    pin_actual_pose=get_actual_tcp_pose()
    of_pin_currentDist=point_dist(startPose,pin_actual_pose)
    actual_deltaD=(actual_deltaD+pose_dist(pin_last_pose,pin_actual_pose))/2
    if(of_threshold(fx=ft_threshold[0],fy=ft_threshold[1],fz=0,tx=ft_threshold[3],ty=ft_threshold[4],tz=ft_threshold[5],force_abs=True,base=base)):
    leaveInsertion=True
    if(of_pin_currentDist<minDistZ):
    pinRet=7
    else:
    pinRet=6
    end
    of_ft_control_stop()
    if not silent:
    popup(of_pin_insertion_exit_maxSideFT,title=of_pin_insertion_exit_title,warning=True,blocking=True)
    end
    elif(pin_useTimeOut and(cntr>timeOut100ms)):
    leaveInsertion=True
    if(of_pin_currentDist<minDistZ):
    pinRet=5
    else:
    pinRet=4
    end
    of_ft_control_stop()
    if not silent:
    popup(of_pin_insertion_exit_timeOut,title=of_pin_insertion_exit_title,warning=True,blocking=True)
    end
    elif(actual_deltaD<deltaD and cntr>=10):
    leaveInsertion=True
    if(of_pin_currentDist<minDistZ):
    pinRet=3
    of_ft_control_stop()
    if not silent:
    popup(of_pin_insertion_exit_deltaD,title=of_pin_insertion_exit_title,warning=True,blocking=True)
    end
    else:
    pinRet=2
    end
    elif(of_pin_currentDist>=minDistZ):
    if bumpZeroPeak:
    bumpZeroPeak=False
    abs0_tFT[2]=True
    sync()
    else:
    if(abs_tFT[2]>norm(forceZ+deltaForce)and not abs0_tFT[2]):
    of_peakFzScanner_flag=False
    leaveInsertion=True
    pinRet=1
    end
    end
    end
    pin_last_pose=pin_actual_pose
    cntr=cntr+1
    sync()
    end
    of_ft_control_stop()
    of_peakFzScanner_flag=False
    kill peakScanner
    of_fpid_i_pin=of_fpid_i_pin_default
    of_fpid_d_pin=of_fpid_d_pin_default
    of_tpid_i_pin=of_tpid_i_pin_default
    of_tpid_d_pin=of_tpid_d_pin_default
    return pinRet
    end
    def of_connector_insertion(distZ,forceZ,forceXY_en0=[True,True],torqueXYZ_en0=[True,True,True],torqueXY=0.1,angR=0.175,speedR=0.01,alpha=0.1,omega=0.4,centeringRate=15,bumpRelative=1,deltaForce=1,PID_Gain=0.5,silent=False,base=True):
    sync()
    of_tcp_offset_send_actual()
    local state=1
    local startPose=get_actual_tcp_pose()
    global of_conn_dist2Reach=distZ
    local dist2StartC=alpha*distZ
    local dist2EndC=omega*distZ
    local forceXY=[0,0]
    local torqueXYZ=[0,0,0]
    local frameID=0
    sync()
    local i=0
    while i<2:
    if forceXY_en0[i]:
    forceXY[i]=0.001
    else:
    forceXY[i]=0
    end
    i=i+1
    end
    i=0
    while i<3:
    if torqueXYZ_en0[i]:
    torqueXYZ[i]=0.0001
    else:
    torqueXYZ[i]=0
    end
    i=i+1
    end
    sync()
    if base:
    forceZ=-norm(forceZ)
    deltaForce=-norm(deltaForce)
    frameID=0
    else:
    forceZ=norm(forceZ)
    deltaForce=norm(deltaForce)
    frameID=1
    end
    angR=norm(angR)
    torqueXY=norm(torqueXY)
    global of_conn_currentDist=0
    sync()
    local peakScanner=run of_peakFzScanner()
    sync()
    local conn_forcePID=[PID_Gain,of_ftpid_i_conn,of_ftpid_d_conn]
    local conn_torquePID=[PID_Gain/of_tpid_div_conn,of_ftpid_i_conn/of_tpid_div_conn,of_ftpid_d_conn/of_tpid_div_conn]
    of_ft_control_start(ft_select=[forceXY_en0[0],forceXY_en0[1],True,torqueXYZ_en0[0],torqueXYZ_en0[1],torqueXYZ_en0[2]],ft_values=[forceXY[0],forceXY[1],forceZ,torqueXYZ[0],torqueXYZ[1],torqueXYZ[2]],frameID=frameID,frameRPY=[0,0,0],forcePID=conn_forcePID,torquePID=conn_torquePID,deviation_max=0)
    of_wait_ms(300)
    local cntr=0
    local bumpEnd=False
    local bumpZeroPeak=True
    of_conn_currentDist=point_dist(startPose,get_actual_tcp_pose())
    while((of_conn_currentDist<distZ)and not bumpEnd):
    if(cntr>centeringRate):
    of_ft_control_stop()
    sync()
    if((of_conn_currentDist>dist2StartC)and(of_conn_currentDist<dist2EndC)):
    local SpeedR=speedR*(1-0.75*of_conn_currentDist/of_conn_dist2Reach)
    local retVal=of_center_RxRy(angR,torqueXY,SpeedR,stateCntr=(cntr*10),silent=silent,base=base)
    sync()
    if(retVal!=0):
    kill peakScanner
    of_ftpid_i_conn=of_ftpid_i_conn_default
    of_ftpid_d_conn=of_ftpid_d_conn_default
    of_tpid_div_conn=of_tpid_div_conn_default
    return retVal
    end
    end
    cntr=0
    if forceXY_en0:
    forceXY=[-1*forceXY[0],-1*forceXY[1]]
    end
    if torqueXYZ_en0:
    torqueXYZ=[-1*torqueXYZ[0],-1*torqueXYZ[1],-1*torqueXYZ[2]]
    end
    of_ft_control_start(ft_select=[forceXY_en0[0],forceXY_en0[1],True,torqueXYZ_en0[0],torqueXYZ_en0[1],torqueXYZ_en0[2]],ft_values=[forceXY[0],forceXY[1],forceZ,torqueXYZ[0],torqueXYZ[1],torqueXYZ[2]],frameID=frameID,frameRPY=[0,0,0],forcePID=conn_forcePID,torquePID=conn_torquePID,deviation_max=0)
    end
    of_wait_ms(100)
    cntr=cntr+1
    of_conn_currentDist=point_dist(startPose,get_actual_tcp_pose())
    sync()
    if(of_conn_currentDist>(distZ*bumpRelative)):
    if bumpZeroPeak:
    bumpZeroPeak=False
    abs0_tFT[2]=True
    sync()
    end
    if base:
    if(bFT[2]>norm(forceZ+deltaForce)):
    bumpEnd=True
    of_peakFzScanner_flag=False
    end
    else:
    if(abs_tFT[2]>norm(forceZ+deltaForce)):
    bumpEnd=True
    of_peakFzScanner_flag=False
    end
    end
    end
    sync()
    end
    sync()
    of_ft_control_stop()
    kill peakScanner
    of_ftpid_i_conn=of_ftpid_i_conn_default
    of_ftpid_d_conn=of_ftpid_d_conn_default
    of_tpid_div_conn=of_tpid_div_conn_default
    return 0
    end
    of__fix_and_rotate_param_error="Parameter error: rotateEndSearch!"
    def of_fix_and_rotate(rotateZ,torqueZ,distZ,forceZ,forceXY_en0=[True,True],torqueXYZ_en0=[True,True,True],torqueXY=0.1,angR=0.175,speedR=0.01,alpha=0.1,omega=0.4,centeringRate=15,bumpRelative=1.0,deltaForce=1,PID_Gain=0.5,rotateEndSearch=1.0,torqueEndSearch=9999,silent=False,base=True):
    if rotateEndSearch<0 and rotateEndSearch>1.0:
    popup(of__fix_and_rotate_param_error,title=of_fix_and_rotate_title,error=True,blocking=False)
    halt
    end
    if torqueEndSearch==9999:
    torqueEndSearch=torqueZ/2
    end
    local moveRz=rotateZ*rotateEndSearch
    local searchRz=rotateZ*norm(1-rotateEndSearch)
    local retConn=of_connector_insertion(distZ,forceZ,forceXY_en0,torqueXYZ_en0,torqueXY,angR,speedR,alpha,omega,centeringRate,bumpRelative,deltaForce,PID_Gain,silent,base=base)
    local retM=0
    if(retConn==0):
    if(rotateZ!=0):
    if(moveRz!=0):
    retM=of_move_ur(rz=moveRz,tz=torqueZ,speed=speedR,acc=speedR*3,silent=True,force_abs=True,base=base)
    else:
    retM=1
    end
    if(retM!=1):
    if not silent:
    popup(of_fix_and_rotate_return_21,title=of_fix_and_rotate_title,warning=True,blocking=True)
    end
    return 21
    else:
    local retS=0
    if(searchRz!=0):
    retS=of_search_ur(rz=searchRz,tz=torqueEndSearch,speed=speedR,acc=speedR*3,silent=True,force_abs=True,base=base)
    else:
    retS=0
    end
    if(retS==1 and rotateEndSearch<1.0):
    if not silent:
    popup(of_fix_and_rotate_return_22,title=of_fix_and_rotate_title,warning=True,blocking=True)
    end
    return 22
    else:
    return 0
    end
    end
    else:
    return 0
    end
    else:
    return 10+retConn
    end
    end
    def of_box_ins(x1=0,y1=0,z1=0,x2=0,y2=0,z2=0,rx=0,ry=0,rz=0,speed=0.03,acc=0.5,brake=2,force=2,torque=0.3,silent=False,insert_force_multiplier=1.5,depth=0,base=True):
    def calc_3d_forces(force,x,y,z,filtering=True):
    local fnorm=sqrt(x*x+y*y+z*z)
    local forces=[-force*x/fnorm,-force*y/fnorm,-force*z/fnorm]
    if not filtering:
    return forces
    end
    i=0
    while i<3:
    if norm(forces[i])<0.1:
    forces[i]=0
    end
    i=i+1
    end
    return forces
    end
    local start_pose=get_actual_tcp_pose()
    sync()
    local ret=of_move_ur(rx=rx,ry=ry,rz=rz,f3d=force*2,t3d=torque*2,speed=speed,acc=acc,brake=brake,silent=True,base=base)
    if ret!=1:
    if not silent:
    popup(of_box_ins_return_4,title=of_box_ins_title,warning=True,blocking=True)
    end
    return 4
    end
    sync()
    local fdir=calc_3d_forces(force,x1,y1,z1)
    local m3d=[x1,y1,z1]
    if base==False:
    fdir=of_rotate_qu(fdir,of_rotvec2qu([-rx,-ry,-rz]))
    m3d=of_rotate_qu([x1,y1,z1],of_rotvec2qu([-rx,-ry,-rz]))
    end
    sync()
    ret=of_search_ur(x=m3d[0],y=m3d[1],z=m3d[2],fx=fdir[0],fy=fdir[1],fz=fdir[2],t3d=torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    if ret==1:
    if not silent:
    popup(of_box_ins_return_1,title=of_box_ins_title,warning=True,blocking=True)
    end
    return 1
    end
    sync()
    if x2!=0 or y2!=0 or z2!=0:
    fdir=calc_3d_forces(force,x2,y2,z2)
    ret=of_search_ur(x=x2,y=y2,z=z2,fx=fdir[0],fy=fdir[1],fz=fdir[2],t3d=2*torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    if ret==1:
    if not silent:
    popup(of_box_ins_return_2,title=of_box_ins_title,warning=True,blocking=True)
    end
    return 2
    end
    end
    local apos=get_actual_tcp_pose()
    ret=of_move_ur(p[apos[0],apos[1],apos[2],start_pose[3],start_pose[4],start_pose[5]],f3d=insert_force_multiplier*force,t3d=insert_force_multiplier*torque,speed=speed,acc=acc,brake=brake,silent=True,base=base)
    if ret!=1:
    if not silent:
    popup(of_box_ins_return_3,title=of_box_ins_title,warning=True,blocking=True)
    end
    return 3
    end
    sync()
    if depth!=0:
    fdir=calc_3d_forces(insert_force_multiplier*force,x1,y1,z1)
    local inserted=False
    local collisions=0
    while not inserted:
    sync()
    local current_dist=pose_dist(get_actual_tcp_pose(),start_pose)
    local move3d=calc_3d_forces(depth-current_dist,-x1,-y1,-z1,filtering=False)
    ret=of_move_ur(x=move3d[0],y=move3d[1],z=move3d[2],fx=fdir[0],fy=fdir[1],fz=fdir[2],t3d=insert_force_multiplier*torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    if ret==2 or ret==0:
    collisions=collisions+1
    if collisions>5:
    if not silent:
    popup(of_box_ins_return_8,title=of_box_ins_title,warning=True,blocking=True)
    end
    return 8
    end
    if move3d[0]==0:
    if of_bi_cp_x_inv:
    of_cp_inv=True
    end
    ret=of_center(x=depth,f3d=insert_force_multiplier*force,t3d=insert_force_multiplier*torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    of_cp_inv=False
    if ret!=0:
    if not silent:
    popup(of_box_ins_return_5,title=of_box_ins_title,warning=True,blocking=True)
    end
    return 5
    end
    end
    if move3d[1]==0:
    if of_bi_cp_y_inv:
    of_cp_inv=True
    end
    ret=of_center(y=depth,f3d=insert_force_multiplier*force,t3d=insert_force_multiplier*torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    of_cp_inv=False
    if ret!=0:
    if not silent:
    popup(of_box_ins_return_6,title=of_box_ins_title,warning=True,blocking=True)
    end
    return 6
    end
    end
    if move3d[2]==0:
    if of_bi_cp_z_inv:
    of_cp_inv=True
    end
    ret=of_center(z=depth,f3d=insert_force_multiplier*force,t3d=insert_force_multiplier*torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    of_cp_inv=False
    if ret!=0:
    if not silent:
    popup(of_box_ins_return_7,title=of_box_ins_title,warning=True,blocking=True)
    end
    return 7
    end
    end
    elif ret==1:
    inserted=True
    end
    end
    end
    return 0
    end
    of__stacking_param_error_dir="Please define only one direction parameter!"
    of__stacking_param_error_itmax="The 'it_max' parameter cannot be greather than the distance/thickness!"
    of__stacking_param_error_thickness="The 'thickness' parameter cannot be zero when 'it_max' is not zero!"
    def of_stacking(start_wp,thickness,it,it_max=0,x=0,y=0,z=0,f3d=0,t3d=0,moveF3D=9999,moveT3D=9999,speed=0.03,moveSpd=0.05,acc=1.2,brake=1.2,move2Start=False,silent=False,base=True):
    local stack_wp=start_wp
    of_stack_curr_it=it
    if(moveF3D==9999):
    moveF3D=2*f3d
    end
    if(moveT3D==9999):
    moveT3D=2*t3d
    end
    if(it_max==0):
    if(thickness==0):
    it=it_max-1
    else:
    it_max=floor(norm((x+y+z)/thickness))
    end
    elif(it_max>norm((x+y+z)/thickness)):
    popup(of__stacking_param_error_itmax,title=of_stacking_title,error=True,blocking=False)
    halt
    elif(thickness==0):
    popup(of__stacking_param_error_thickness,title=of_stacking_title,error=True,blocking=False)
    halt
    end
    local it_end=floor(norm((x+y+z)/thickness))
    local delta=0
    local deltaMax=0
    if(thickness>0):
    delta=norm(thickness*(it_end-of_stack_curr_it-1))
    elif(thickness<0):
    delta=norm(thickness*of_stack_curr_it)
    end
    local offset=p[0,0,0,0,0,0]
    local db=0
    if x!=0:
    db=db+1
    offset=p[delta*x/norm(x),0,0,0,0,0]
    offsetMax=p[x,0,0,0,0,0]
    end
    if y!=0:
    db=db+1
    offset=p[0,delta*y/norm(y),0,0,0,0]
    offsetMax=p[0,y,0,0,0,0]
    end
    if z!=0:
    db=db+1
    offset=p[0,0,delta*z/norm(z),0,0,0]
    offsetMax=p[0,0,z,0,0,0]
    end
    if db==0:
    popup(of__stacking_param_error_dir,title=of_stacking_title,error=True,blocking=False)
    halt
    end
    if db>1:
    popup(of__stacking_param_error_dir,title=of_stacking_title,error=True,blocking=False)
    halt
    end
    if delta==0.0:
    offset=p[0,0,0,0,0,0]
    end
    if move2Start:
    local mRet=of_move_ur(target=start_wp,f3d=moveF3D,t3d=moveT3D,speed=moveSpd,acc=acc,brake=brake,silent=True,force_abs=True,base=base)
    if(mRet!=1):
    if not silent:
    popup(of_stacking_return_5,title=of_stacking_title,warning=True,blocking=True)
    end
    return 5
    end
    end
    if(it>=it_max):
    if not silent:
    if(thickness>0):
    popup(of_stacking_return_1_stack,title=of_stacking_title,warning=True,blocking=True)
    else:
    popup(of_stacking_return_1_destack,title=of_stacking_title,warning=True,blocking=True)
    end
    end
    of_stack_curr_it=0
    return 1
    end
    stack_wp=of_pose_add(start_wp,offset,base)
    local stack_max_wp=of_pose_add(start_wp,offsetMax,base)
    local mRet=of_move_ur(target=stack_wp,f3d=moveF3D,t3d=moveT3D,speed=moveSpd,acc=acc,brake=brake,silent=True,force_abs=True,base=base)
    if(mRet!=1):
    if not silent:
    popup(of_stacking_return_4,title=of_stacking_title,warning=True,blocking=True)
    end
    return 4
    end
    local sRet=of_search_ur(target=stack_max_wp,f3d=f3d,t3d=t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=True,base=base)
    if(sRet==2):
    elif(sRet==1):
    if not silent:
    popup(of_stacking_return_2,title=of_stacking_title,warning=True,blocking=True)
    end
    return 2
    else:
    if not silent:
    popup(of_stacking_return_3,title=of_stacking_title,warning=True,blocking=True)
    end
    return 3
    end
    of_stack_curr_it=of_stack_curr_it+1
    return 0
    end
    def of_stacking_last_it():
    return of_stack_curr_it
    end
    def of_get_virt_orient(virt_pose):
    local retVal=[virt_pose[3],virt_pose[4],virt_pose[5]]
    textmsg("virt_orient: ",retVal)
    return retVal
    end
    def of_polishing(forceAmp,forceDir,pidGain=[1.0,1.0,1.0]):
    local force_orient=of_get_virt_orient(forceDir)
    local frameRotVec=rpy2rotvec(force_orient)
    of_ft_control_start(ft_select=[False,False,True,False,False,False],ft_values=[0,0,forceAmp,0,0,0],frameID=0,frameRPY=frameRotVec,forcePID=pidGain,torquePID=pidGain,deviation_max=0)
    end
  
  
    #======    End of OnRobot Applications    ======#
  
    #======    OnRobot Gripper Set Width Messages    ======#
  
    of_gripper_set_width_error_title="OnRobot - Gripper Set Width error"
    of_gripper_set_width_state_error_start="Wrong Gripper Set Width status when initializing.<br>Another thread is using a Gripper Set Width command. Program stopped."
    of_gripper_set_width_state_error_return="Wrong Gripper Set Width status when returning.<br>Another thread is using a Gripper Set Width command. Program stopped."
    of_gripper_set_width_return_title="OnRobot - Gripper Set Width"
    of_gripper_set_width_return_nonblocking="The Gripper Set Width non-blocking command sent."
    of_gripper_set_width_return_0="The Gripper Set Width command reached the set width."
    of_gripper_set_width_return_1="The Gripper Set Width command reached the set force."
    of_gripper_set_width_return_PE="The Gripper Set Width command has a parameter error.<br>Program stopped."
    of_gripper_set_width_return_unknown="The Gripper Set Width command finished with unknown return value."
  
  
    #======    End of OnRobot Gripper Set Width Messages    ======#
  
    #======    OnRobot Gripper Set Width    ======#
  
    of_gripper_set_width_state=0
    of_gripper_set_width_return=0
    OF_GRIPPER_MAX_WIDTH=120
    OF_GRIPPER_MAX_FORCE=40
    OF_GRIPPER_SET_WIDTH_STATE_IDLE=0
    OF_GRIPPER_SET_WIDTH_STATE_INIT=1
    OF_GRIPPER_SET_WIDTH_STATE_STARTED=2
    OF_GRIPPER_SET_WIDTH_STATE_RETURNING=3
    of__gripper_set_width_param_error_width="Please define parameter 'width' as a positive real number in millimeters!"
    of__gripper_set_width_param_warning_width="The parameter 'width' is higher than the maximum value. Maximum value sent: "
    of__gripper_set_width_param_error_force="Please define parameter 'force' as a positive  real number in Newtons!"
    of__gripper_set_width_param_warning_force="The parameter 'force' higher than the maximum value. Maximum value sent: "
    def of_gripper_set_width(width,force,blocking=True,depth_compensation=False,popupmsg=True):
    sync()
    if OF_DEBUG_STATE:
    textmsg("Gripper Set Width starting..")
    end
    if not(of_gripper_set_width_state==OF_GRIPPER_SET_WIDTH_STATE_IDLE):
    textmsg("of_gripper_set_width_state: ",of_gripper_set_width_state)
    popup(of_gripper_set_width_state_error_start,title=of_cmd_error_title,error=True,blocking=False)
    halt
    else:
    enter_critical
    of_gripper_set_width_state=OF_GRIPPER_SET_WIDTH_STATE_INIT
    exit_critical
    end
    enter_critical
    of_gripper_set_width_return=0
    exit_critical
    if not(width>=0):
    of_gripper_set_width_return=-99
    popup(of__gripper_set_width_param_error_width,title=of_gripper_set_width_error_title,error=True,blocking=False)
    elif not(width<=OF_GRIPPER_MAX_WIDTH):
    width=OF_GRIPPER_MAX_WIDTH
    textmsg(of__gripper_set_width_param_warning_width,width)
    elif not(force>0):
    of_gripper_set_width_return=-99
    popup(of__gripper_set_width_param_error_force,title=of_gripper_set_width_error_title,error=True,blocking=False)
    elif not(force<=OF_GRIPPER_MAX_FORCE):
    force=OF_GRIPPER_MAX_FORCE
    textmsg(of__gripper_set_width_param_warning_force,force)
    end
    if(of_gripper_set_width_return!=0):
    halt
    end
    local blocking_int=binary_list_to_integer([blocking])
    local depth_compensation_int=binary_list_to_integer([depth_compensation])
    of_send_full(OF_CMD_GRIPPER_SET_WIDTH,of_float_to_int(width),of_float_to_int(force),blocking_int,depth_compensation_int)
    if depth_compensation:
    of_speedl_start_for_CMD(OF_CMD_GRIPPER_SET_WIDTH)
    end
    if OF_DEBUG_STATE:
    textmsg("Gripper Set Width command sent, waiting for the return.")
    end
    enter_critical
    of_gripper_set_width_state=OF_GRIPPER_SET_WIDTH_STATE_STARTED
    exit_critical
    of_gripper_set_width_return=of_wait_for_return(OF_CMD_GRIPPER_SET_WIDTH,blocking=blocking)
    if depth_compensation:
    of_speedl_stop_for_CMD(OF_CMD_GRIPPER_SET_WIDTH)
    end
    if(of_gripper_follow_tcp):
    of_gripper_tcp_update()
    end
    if(of_gripper_follow_cog):
    of_gripper_cog_update()
    end
    if OF_DEBUG_STATE:
    textmsg("Gripper Set Width returned.")
    end
    if of_gripper_set_width_return==-1:
    elif of_gripper_set_width_return==0:
    elif of_gripper_set_width_return==1:
    if(popupmsg):
    popup(of_gripper_set_width_return_1,title=of_gripper_set_width_return_title,warning=True,blocking=True)
    end
    else:
    textmsg("of_gripper_set_width_return: ",of_gripper_set_width_return)
    popup(of_gripper_set_width_return_unknown,title=of_gripper_set_width_return_title,warning=True,blocking=True)
    end
    enter_critical
    of_gripper_set_width_state=OF_GRIPPER_SET_WIDTH_STATE_IDLE
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("End of Gripper Set Width.")
    end
    return of_gripper_set_width_return
    end
  
  
    #======    End of OnRobot Gripper Set Width    ======#
  
    #======    OnRobot Gripper Set LEDs Messages    ======#
  
    of_gripper_set_LEDs_error_title="OnRobot - Gripper Set LEDs error"
    of_gripper_set_LEDs_error_no_select="Please select at least one finger sensor LED."
  
  
    #======    End of OnRobot Gripper Set LEDs Messages    ======#
  
    #======    OnRobot Gripper Set LEDs    ======#
  
    of__gripper_set_LEDs_error_RGB0="Please define parameter RGB[0] (red) as an integer between 0 and 255."
    of__gripper_set_LEDs_error_RGB1="Please define parameter RGB[1] (green) as an integer between 0 and 255."
    of__gripper_set_LEDs_error_RGB2="Please define parameter RGB[2] (blue) as an integer between 0 and 255."
    def of_gripper_set_LEDs(RGB=[0,0,0],forLeftLED=True,forRightLED=True):
    sync()
    if OF_DEBUG_STATE:
    textmsg("Gripper Stop command starting..")
    end
    local parameter_error=False
    if not(RGB[0]>=0 and RGB[0]<=255):
    parameter_error=True
    popup(of__gripper_set_LEDs_error_RGB0,title=of_gripper_set_LEDs_error_title,error=True,blocking=False)
    elif not(RGB[1]>=0 and RGB[1]<=255):
    parameter_error=True
    popup(of__gripper_set_LEDs_error_RGB1,title=of_gripper_set_LEDs_error_title,error=True,blocking=False)
    elif not(RGB[2]>=0 and RGB[2]<=255):
    parameter_error=True
    popup(of__gripper_set_LEDs_error_RGB2,title=of_gripper_set_LEDs_error_title,error=True,blocking=False)
    elif not(forLeftLED or forRightLED):
    parameter_error=True
    popup(of_gripper_set_LEDs_error_no_select,title=of_gripper_set_LEDs_error_title,error=True,blocking=False)
    end
    if(parameter_error):
    halt
    end
    flags=binary_list_to_integer([forLeftLED,forRightLED])
    of_send_full(OF_CMD_GRIPPER_SET_LEDS,RGB[0],RGB[1],RGB[2],flags)
    return 0
    end
  
  
    #======    End of OnRobot Gripper Set LEDs    ======#
  
    #======    OnRobot Gripper Stop Messages    ======#
  
  
  
    #======    End of OnRobot Gripper Stop Messages    ======#
  
    #======    OnRobot Gripper Stop    ======#
  
    def of_gripper_stop():
    sync()
    if OF_DEBUG_STATE:
    textmsg("Gripper Stop command starting..")
    end
    of_send_full(OF_CMD_GRIPPER_STOP)
    of_speedl_stop_for_CMD(OF_CMD_GRIPPER_SET_WIDTH)
    of_wait_for_return_stop(OF_CMD_GRIPPER_SET_WIDTH)
    of_speedl_stop_for_CMD(OF_CMD_GRIPPER_CENTERING)
    of_wait_for_return_stop(OF_CMD_GRIPPER_CENTERING)
    if OF_DEBUG_STATE:
    textmsg("End of Gripper Stop.")
    end
    end
  
  
    #======    End of OnRobot Gripper Stop    ======#
  
    #======    OnRobot Gripper Centering Messages    ======#
  
    of_gripper_centering_title="OnRobot - Gripper Centering"
    of_gripper_centering_start_error="Gripper Centering state error. Program stopped."
  
  
    #======    End of OnRobot Gripper Centering Messages    ======#
  
    #======    OnRobot Gripper Centering    ======#
  
    of_gripper_centering_state=0
    OF_GRIPPER_CENTERING_STATE_IDLE=0
    OF_GRIPPER_CENTERING_STATE_RUNNING=1
    def of_gripper_centering_enable(gain,pow_gain=0.05):
    sync()
    if OF_DEBUG_STATE:
    textmsg("Gripper Centering Enable starting..")
    end
    if not(of_gripper_centering_state==OF_GRIPPER_CENTERING_STATE_IDLE):
    textmsg("of_gripper_centering_state: ",of_gripper_centering_state)
    popup(of_gripper_centering_start_error,title=of_gripper_centering_title,error=True,blocking=False)
    halt
    else:
    of_gripper_centering_state=OF_GRIPPER_CENTERING_STATE_RUNNING
    end
    enableFlag=binary_list_to_integer([True])
    of_send_full(OF_CMD_GRIPPER_CENTERING,enableFlag,of_float_to_int(gain),of_float_to_int(pow_gain))
    of_speedl_start_for_CMD(OF_CMD_GRIPPER_CENTERING)
    if OF_DEBUG_STATE:
    textmsg("End of Gripper Centering Enable.")
    end
    end
    def of_gripper_centering_disable():
    if OF_DEBUG_STATE:
    textmsg("Start of Gripper Centering Disable.")
    end
    enableFlag=binary_list_to_integer([False])
    of_send_full(OF_CMD_GRIPPER_CENTERING,enableFlag,0,0)
    of_speedl_stop_for_CMD(OF_CMD_GRIPPER_CENTERING)
    enter_critical
    of_gripper_centering_state=OF_GRIPPER_CENTERING_STATE_IDLE
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("Gripper Centering Disabled.")
    end
    end
  
  
    #======    End of OnRobot Gripper Centering    ======#
  
    #======    OnRobot Gripper Proximity Offsets Messages    ======#
  
  
  
    #======    End of OnRobot Gripper Proximity Offsets Messages    ======#
  
    #======    OnRobot Gripper Proximity Offsets    ======#
  
    gProxL_offset=0
    gProxR_offset=0
    of__gripper_proxi_offset_error_title="OnRobot - Gripper Proxi Offset"
    of__gripper_proxi_offset_error_ProxL="Please define parameter 'ProxL' as an integer between -200 and 200."
    of__gripper_proxi_offset_error_ProxR="Please define parameter 'ProxR' as an integer between -200 and 200."
    def of_gripper_proxi_offsets(ProxL=0,ProxR=0):
    sync()
    if OF_DEBUG_STATE:
    textmsg("Gripper Proximity Offsets command starting..")
    end
    local parameter_error=False
    if not(ProxL>=-200 and ProxL<=200):
    parameter_error=True
    popup(of__gripper_proxi_offset_error_ProxL,title=of__gripper_proxi_offset_error_title,error=True,blocking=False)
    elif not(ProxR>=-200 and ProxR<=200):
    parameter_error=True
    popup(of__gripper_proxi_offset_error_ProxR,title=of__gripper_proxi_offset_error_title,error=True,blocking=False)
    end
    if(parameter_error):
    halt
    end
    gProxL_offset=ProxL
    gProxR_offset=ProxR
    of_send_full(OF_CMD_GRIPPER_PROXI_OFFSETS,of_float_to_int(ProxL),of_float_to_int(ProxR))
    if OF_DEBUG_STATE:
    textmsg("Gripper Proximity Offsets command stopping..")
    end
    end
    of_gripper_proxi_offsets(of_proxi_offsets[0],of_proxi_offsets[1])
  
  
    #======    End of OnRobot Gripper Proximity Offsets    ======#
  
    #======    OnRobot Gripper Proximity Averaging Window Messages    ======#
  
  
  
    #======    End of OnRobot Gripper Proximity Averaging Window Messages    ======#
  
    #======    OnRobot Gripper Proximity Averaging Window    ======#
  
    of_gProx_avg_window_default=10
    of_gProx_avg_window=10
    of_gProx_avg_window_last=of_gProx_avg_window
    of__gripper_proxi_avg_window_error_title="OnRobot - Gripper Proximity"
    of__gripper_proxi_avg_window_error_windowSize="Please define parameter windowSize as a positive integer between 0 and 20."
    def of_gripper_proxi_avg_window_set(windowSize=10):
    sync()
    if OF_DEBUG_STATE:
    textmsg("Gripper Proxi Avg Window Set command starting..")
    end
    if not(windowSize>0 and windowSize<=20):
    popup(of__gripper_proxi_avg_window_error_windowSize,title=of__gripper_proxi_avg_window_error_title,error=True,blocking=False)
    halt
    end
    of_gProx_avg_window_last=of_gProx_avg_window
    of_gProx_avg_window=windowSize
    of_send_full(OF_CMD_GRIPPER_PROXI_AVG_WINDOW,windowSize)
    if OF_DEBUG_STATE:
    textmsg("Gripper Proxi Avg Window Set command ended.")
    end
    end
    def of_gripper_proxi_avg_window_reset_last():
    of_gripper_proxi_avg_window_set(of_gProx_avg_window_last)
    end
    def of_gripper_proxi_avg_window_reset_default():
    of_gripper_proxi_avg_window_set(of_gProx_avg_window_default)
    end
  
  
    #======    End of OnRobot Gripper Proximity Averaging Window    ======#
  
    #======    OnRobot Gripper Width Filtering Messages    ======#
  
  
  
    #======    End of OnRobot Gripper Width Filtering Messages    ======#
  
    #======    OnRobot Gripper Width Filtering    ======#
  
    of_gWidth_filter=10
    of__gripper_width_filtering_error_title="OnRobot - Gripper Proximity"
    of__gripper_width_filtering_error_bufferSize="Please define parameter bufferSize as a positive integer between 0 and 20."
    def of_gripper_width_filtering_set(bufferSize=10):
    sync()
    if OF_DEBUG_STATE:
    textmsg("Gripper Width filtering set command starting..")
    end
    if not(bufferSize>0 and bufferSize<=20):
    popup(of__gripper_width_filtering_error_bufferSize,title=of__gripper_width_filtering_error_title,error=True,blocking=False)
    halt
    end
    of_gWidth_filter=bufferSize
    of_send_full(OF_CMD_GRIPPER_WIDTH_FILTERING,bufferSize)
    if OF_DEBUG_STATE:
    textmsg("Gripper Width filtering set command stopping..")
    end
    end
  
  
    #======    End of OnRobot Gripper Width Filtering    ======#
  
    #======    OnRobot Gripper Detect Part Messages    ======#
  
    of_gripper_detect_part_title="OnRobot - Gripper Detect Part"
    of_gripper_detect_part_detected="Part detected."
    of_gripper_detect_part_not_detected="Nothing detected with the Detect Part command."
  
  
    #======    End of OnRobot Gripper Detect Part Messages    ======#
  
    #======    OnRobot Gripper Detect Part    ======#
  
    RG_DETECT_PART_NO_WIDTH_MAX=999
    OF_DEBUG_DETECT_PART=False
    of__gripper_detect_part_width_error_detector="No detect mode selected.<br>Please set at least one element of parameter 'detector' to True."
    of__gripper_detect_part_width_error_width_threshold="Please define parameter Width Threshold as a positive real number."
    of__gripper_detect_part_width_error_width_max="Please define parameter Width Max as a positive real number."
    of__gripper_detect_part_width_error_force_threshold="Please define parameter Force Threshold as a positive real number."
    def of_gripper_detect_part_check(detector=[False,False],width_threshold=0,width_max=RG_DETECT_PART_NO_WIDTH_MAX,force_threshold=0):
    if OF_DEBUG_STATE and OF_DEBUG_DETECT_PART:
    textmsg("Gripper Detect Part Check starting..")
    end
    local parameter_error=False
    if not(detector[0]or detector[1]):
    popup(of__gripper_detect_part_width_error_detector,title=of_gripper_detect_part_title,error=True,blocking=False)
    parameter_error=True
    end
    if not((detector[0]and width_threshold>=0)or not detector[0]):
    popup(of__gripper_detect_part_width_error_width_threshold,title=of_gripper_detect_part_title,error=True,blocking=False)
    parameter_error=True
    end
    if not((detector[0]and((width_max>=width_threshold)or(width_max==RG_DETECT_PART_NO_WIDTH_MAX)))or not detector[0]):
    popup(of__gripper_detect_part_width_error_width_max,title=of_gripper_detect_part_title,error=True,blocking=False)
    parameter_error=True
    end
    if not((detector[1]and force_threshold>0)or not detector[1]):
    popup(of__gripper_detect_part_width_error_force_threshold,title=of_gripper_detect_part_title,error=True,blocking=False)
    parameter_error=True
    end
    if(parameter_error):
    halt
    end
    local part_detected=False
    local ft_limit_reached=False
    local prox_limit_reached=False
    if detector[0]:
    local partWidth=rg_Part_width
    if width_max==RG_DETECT_PART_NO_WIDTH_MAX:
    prox_limit_reached=(width_threshold<=partWidth)
    else:
    prox_limit_reached=((width_threshold<=partWidth)and(width_max>=partWidth))
    end
    end
    if detector[1]:
    ft_limit_reached=(force_threshold<=rg_F3D_right)or(force_threshold<=rg_F3D_left)
    end
    part_detected=ft_limit_reached or prox_limit_reached
    if OF_DEBUG_STATE and OF_DEBUG_DETECT_PART:
    textmsg("End of Gripper Detect Part Check.")
    end
    return part_detected
    end
  
  
    #======    End of OnRobot Gripper Detect Part    ======#
  
    #======    OnRobot Gripper Measure Part Messages    ======#
  
  
  
    #======    End of OnRobot Gripper Measure Part Messages    ======#
  
    #======    OnRobot Gripper Measure Part    ======#
  
    of__gripper_measure_part_title="OnRobot - Gripper Measure Part"
    of__gripper_measure_part_error_mode="Unknown measurement mode.<br>Please define parameter 'mode' as a valid measurement mode."
    of__gripper_measure_part_width_error_resolution="Please define parameter 'resolution' as a positive integer."
    of__gripper_measure_part_weigth_error_resolution="Please define parameter 'resolution' as a positive integer."
    def of_gripper_measure_part_width(mode=0,resolution=10,closingForce=10):
    if OF_DEBUG_STATE:
    textmsg("Gripper Measure Part Width starting..")
    end
    local parameter_error=False
    if not(resolution>0):
    popup(of__gripper_measure_part_width_error_resolution,title=of__gripper_measure_part_title,error=True,blocking=False)
    parameter_error=True
    end
    if not(mode==0 or mode==1):
    popup(of__gripper_measure_part_error_mode,title=of__gripper_measure_part_title,error=True,blocking=False)
    parameter_error=True
    end
    if(parameter_error):
    halt
    end
    local part_width=0
    of_gripper_width_filtering_set(resolution)
    local i=0
    if(mode==0):
    while(i<resolution):
    i=i+1
    sync()
    end
    part_width=rg_Part_width
    elif(mode==1):
    local lastGripperWidth=rg_Width
    of_gripper_centering_enable(1)
    of_gripper_set_width(0,closingForce,blocking=True,depth_compensation=True,popupmsg=False)
    of_gripper_centering_disable()
    sync()
    part_width=rg_Width
    sync()
    of_gripper_set_width(lastGripperWidth,closingForce,blocking=True,depth_compensation=True,popupmsg=False)
    else:
    popup(of__gripper_measure_part_error_mode,title=of__gripper_measure_part_title,error=True,blocking=False)
    halt
    end
    if OF_DEBUG_STATE:
    textmsg("End of Gripper Measure Part Width.")
    end
    return part_width
    end
    def of_gripper_measure_part_weigth(mode=1,resolution=10):
    if OF_DEBUG_STATE:
    textmsg("Gripper Measure Part Weigth starting..")
    end
    local parameter_error=False
    if not(resolution>0):
    popup(of__gripper_measure_part_weigth_error_resolution,title=of__gripper_measure_part_title,error=True,blocking=False)
    parameter_error=True
    end
    if not(mode==1):
    popup(of__gripper_measure_part_error_mode,title=of__gripper_measure_part_title,error=True,blocking=False)
    parameter_error=True
    end
    if(parameter_error):
    halt
    end
    of_gripper_width_filtering_set(resolution)
    local part_weigth_sum=0.0
    local i=0
    while(i<resolution):
    part_weigth_sum=part_weigth_sum+rg_Part_weight
    i=i+1
    sync()
    end
    local part_weigth=part_weigth_sum/resolution
    if OF_DEBUG_STATE:
    textmsg("End of Gripper Measure Part Weigth.")
    end
    return part_weigth
    end
  
  
    #======    End of OnRobot Gripper Measure Part    ======#
